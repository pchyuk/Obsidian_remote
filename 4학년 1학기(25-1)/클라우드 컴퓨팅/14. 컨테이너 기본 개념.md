## 1. 핵심 개념

### 1.1 컨테이너의 정의 및 특징

- **컨테이너란 무엇인가?:** 애플리케이션 소프트웨어를 운영체제로부터 분리시켜 필요한 최소한의 실행 환경을 제공하는 샌드박스화된 런타임 환경.
- **샌드박스화의 의미:** 프로세스가 보호된 영역에서 동작하여 호스트 시스템에 부정적인 영향을 미치는 것으로부터 보호됨.
- **패키징 기술로서의 컨테이너:** 애플리케이션과 그 동작에 필요한 라이브러리 및 완전히 독립된 환경을 포함하여 패키징함.

### 1.2 컨테이너의 장점 

- **Standard (규격화):** 규격화된 컨테이너 사용으로 일관성 유지.
- **Portable (이동성):** 컨테이너는 환경에 구애받지 않고 쉽게 이동 가능.
- **Light Weight (경량성):** 효율적인 자원 사용으로 가볍게 동작.
- **Security & Protection (보안 및 보호):** 컨테이너별 독립적인 보안 및 안전장치 제공.

### 1.3 네이티브 방식 vs. 컨테이너 방식 (개념 비교)

## 2. 컨테이너 기술의 역사 및 발전 과정

### 2.1 초기 분리 기술

- **Unix V7 Change Root (chroot, 1979):** 프로세스의 루트 디렉터리를 변경하여 프로세스 간 분리 구현.
- 애플리케이션 개발, 테스트, 의존성 제어, 권한 분리에 사용.
- **FreeBSD Jail (2000):** FreeBSD 시스템을 독립된 작은 시스템(Jail)으로 분리하는 운영체제 수준의 가상화.
- chroot보다 더 광범위한 프로세스 동작 분리.
- **Linux Vserver (2001):** FreeBSD Jail과 유사하게 리눅스에서 CPU 시간, 메모리, 파일 시스템 등 시스템 리소스 분리 (Security Context, Virtual Private Server).
- **Solaris Containers (2004):**'존(zone)' 개념을 도입하여 자원 분리 및 프로세스 간 엄격한 상호작용 분리.
- **Open VZ (2005):** Virtuozzo에서 오픈소스로 제공하는 리눅스 커널 패치를 통한 운영체제 수준 가상화.
- **Google의 Process Container (2006) / cgroup:** CPU, 메모리, 디스크 I/O, 네트워크 등 컴퓨터 자원에 대한 프로세스 사용량 제한.
- 이후 'cgroup(control group)'으로 명칭 변경.

### 2.2 현대 컨테이너 기술의 발전

- **LXC (Linux Containers, 2008):** 리눅스 기반 운영체제 수준 가상화 기술.
- cgroup과 네임스페이스 분리 기술을 활용.
- **cgroup:** 자원 사용 제한 및 우선순위 제공.
- **네임스페이스 분리:** 프로세스 트리, 네트워킹, 사용자 ID, 마운트 파일 시스템 등 운영체제 환경 분리.
- **Docker (2013):** LXC를 활용하여 컨테이너를 쉽게 사용할 수 있게 함.
- 이후 LXC를 libcontainer로 대체하며 컨테이너 기술 보편화에 크게 기여 ("Build Once, Run Anywhere").
- **Kubernetes (2015):** Google에서 오픈소스로 공개한 컨테이너 오케스트레이션 툴.
- IT 서비스에서 컨테이너의 활발한 사용에 따라 개발되었으며, 컨테이너 관리를 위한 표준으로 수렴 중.
- CNCF(Cloud Native Computing Foundation)에 기증(2016).
- **Container Security Issue (2016) - Dirty COW:** 컨테이너 시스템의 복잡도 증가에 따른 보안 문제 발생 (예: Dirty COW 취약점).
- DevSecOps(개발 단계부터 보안을 개입시키는 트렌드)의 중요성 대두.
- **OCI (Open Container Initiative, 2017):** 도커에 대한 과도한 종속성을 피하기 위해 컨테이너 포맷 및 런타임에 대한 개방형 표준 개발 목적으로 2015년 구성.
- OCI 컨테이너 버전 표준 v1.0 발표 (2017).
- CRI(Container Runtime Interface)와 CRI-O 발표.
- **CRI:** 쿠버네티스 컨테이너 런타임 인터페이스.
- **CRI-O:** OCI 기반 표준 컨테이너 런타임.
- **CRI-O의 등장 배경:** 도커가 컨테이너 실행 과정의 마지막 단계만 표준화한 반면, 쿠버네티스는 다양한 컨테이너 런타임을 지원할 필요성 때문에 CRI를 개발.
- **도커, OCI, 쿠버네티스, CRI-O, CNCF의 관계:** OCI: 컨테이너 표준 스펙 정의.
- 컨테이너 런타임 (Docker, CRI-O, RKT, Containerd): OCI 표준 스펙에 따라 구현.
- Kubernetes: 컨테이너 런타임을 제어하는 오케스트레이션 툴.
- CNCF: 쿠버네티스 개발 및 유지 관리.

## 3. 컨테이너 vs. 가상머신 (VM)

### 3.1 컨테이너는 가상화인가?

- 완벽한 가상화는 아님. 독립된 환경 및 다른 컨테이너에 영향을 주지 않는다는 점은 VM과 유사하나, 독립된 운영체제를 갖지 않는다는 점에서 VM과 차이.

### 3.2 성능 비교 (Native, Docker, KVM)

- 일반적으로 Native > Docker > KVM 순으로 성능이 우수.

### 3.3 컨테이너가 유리한 경우

- 애플리케이션이 멀티서비스(마이크로서비스) 아키텍처인 경우.
- 서버 수를 최소화하고자 할 때.
- 클라우드 네이티브 애플리케이션 개발 (작고, 독립적이고, 상호 결합도가 낮은 서비스).
- 애플리케이션 개발 환경이 배포 환경과 유사해야 할 때.

### 3.4 가상머신이 유리한 경우

- 애플리케이션이 모노리식 아키텍처인 경우.
- 서로 다른 운영체제가 필요한 경우.
- 플랫폼에 고정된 스토리지 시스템이 필요한 경우.
- 운영체제의 많은 기능이 필요한 경우.

## 2. 10가지 단답형 문제

각 질문에 대해 2-3문장으로 답하시오.

1. 컨테이너의 "샌드박스화되었다"는 것은 무엇을 의미하며, 이는 호스트 시스템에 어떤 이점을 제공합니까?
2. 컨테이너 기술이 "패키징 기술"이라고 불리는 이유는 무엇입니까? 패키징 대상에는 무엇이 포함됩니까?
3. Unix V7의 chroot 기술은 컨테이너의 어떤 핵심 개념을 구현했으며, 그 한계점은 무엇이었습니까?
4. FreeBSD Jail은 chroot와 비교하여 어떤 점에서 진보된 가상화 기술이었습니까? 기술 탄생 배경은 무엇입니까?
5. Google의 Process Container가 나중에 'cgroup'으로 명칭이 변경된 이유는 무엇이며, cgroup은 어떤 기능을 제공합니까?
6. Docker는 컨테이너 기술 보편화에 어떻게 기여했으며, "Build Once, Run Anywhere"라는 슬로건이 의미하는 바는 무엇입니까?
7. Kubernetes가 등장하게 된 배경은 무엇이며, 컨테이너 생태계에서 어떤 역할을 수행하고 있습니까?
8. OCI(Open Container Initiative)가 설립된 주요 목적은 무엇이며, OCI의 표준화 노력은 컨테이너 기술에 어떤 영향을 미쳤습니까?
9. 컨테이너와 가상머신(VM)의 주요 차이점은 무엇입니까? 두 기술이 공유하는 공통점은 무엇입니까?
10. 컨테이너 기반 아키텍처가 가상머신(VM)보다 유리한 대표적인 두 가지 경우는 무엇입니까?

## 3. 단답형 문제 정답

1. 컨테이너가 "샌드박스화되었다"는 것은 프로세스가 호스트 시스템의 다른 부분과 격리된 보호된 영역에서 동작한다는 것을 의미합니다. 이는 애플리케이션이 호스트 시스템에 부정적인 영향을 미치는 것을 방지하고 보안성을 높이는 이점을 제공합니다.
2. 컨테이너 기술이 "패키징 기술"이라고 불리는 이유는 애플리케이션과 그 애플리케이션이 동작하는 데 필요한 모든 환경(라이브러리 포함)을 독립적으로 분리하여 하나로 묶기 때문입니다. 이를 통해 애플리케이션이 어떤 환경에서든 일관되게 실행될 수 있도록 보장합니다.
3. Unix V7의 chroot 기술은 프로세스의 루트 디렉터리를 변경하여 프로세스 간의 분리를 구현했습니다. 하지만 이는 단순히 파일 시스템 격리에 불과했고, 프로세스 자체나 네트워크, 메모리 같은 다른 시스템 자원의 완전한 격리까지는 제공하지 못하는 한계가 있었습니다.
4. FreeBSD Jail은 chroot와 달리 운영체제 수준의 가상화를 통해 컴퓨터 시스템을 여러 개의 독립된 작은 시스템('Jail')으로 분리했습니다. 이는 호스팅 프로바이더가 고객 환경과 자사 환경을 분리하려는 시도에서 탄생했으며, chroot보다 더 광범위한 프로세스 동작 분리를 가능하게 했습니다.
5. Google의 Process Container는 '컨테이너'라는 용어의 혼동을 피하기 위해 'cgroup'으로 명칭이 변경되었습니다. cgroup은 CPU, 메모리, 저장장치 등과 같은 컴퓨터 자원에 대한 프로세스의 사용량을 제한하고 우선순위를 제공하는 기능을 담당합니다.
6. Docker는 LXC를 활용하여 컨테이너를 쉽게 활용할 수 있는 기술을 제공함으로써 컨테이너 기술의 보편화에 크게 기여했습니다. "Build Once, Run Anywhere"는 한 번 컨테이너로 패키징된 애플리케이션은 어떤 환경에서든 동일하게 실행될 수 있다는 컨테이너의 이식성을 강조하는 슬로건입니다.
7. Kubernetes는 IT 서비스에서 컨테이너 사용이 활발해지면서 컨테이너의 배포, 확장, 관리를 자동화하는 '오케스트레이션'의 필요성으로 등장했습니다. 이는 복잡한 컨테이너 기반 시스템을 효율적으로 관리하고, 다양한 컨테이너 런타임을 제어하는 표준 툴로서 중요한 역할을 수행합니다.
8. OCI(Open Container Initiative)는 특정 솔루션(예: Docker)에 대한 과도한 종속성을 피하고 컨테이너 포맷과 런타임에 대한 개방형 표준을 개발하기 위해 설립되었습니다. OCI의 표준화 노력은 컨테이너 생태계의 상호운용성을 높이고 다양한 컨테이너 기술의 발전을 촉진했습니다.
9. 컨테이너와 가상머신(VM)의 주요 차이점은 컨테이너는 호스트 운영체제의 커널을 공유하며 독립된 운영체제를 갖지 않는 반면, VM은 각기 독립된 운영체제와 커널을 가진다는 점입니다. 공통점으로는 둘 다 애플리케이션과 그 환경을 격리하여 실행할 수 있는 독립된 환경을 제공한다는 점입니다.
10. 컨테이너 기반 아키텍처가 가상머신보다 유리한 대표적인 두 가지 경우는 애플리케이션이 작고 독립적인 서비스로 구성된 멀티서비스(마이크로서비스) 아키텍처일 때와 애플리케이션 개발 환경과 배포 환경을 유사하게 유지해야 할 때입니다. 컨테이너는 이러한 환경에서 경량성, 이식성, 빠른 배포의 장점을 가집니다.

## 4. 에세이 형식 질문 (답변 없음)

1. 컨테이너 기술의 발전 과정을 Unix V7 chroot부터 Kubernetes까지 주요 기술별로 설명하고, 각 기술이 이전 기술의 한계를 어떻게 극복하며 컨테이너의 '분리(isolation)' 개념을 어떻게 발전시켰는지 상세히 논하시오.
2. 컨테이너 기술의 장점인 Standard, Portable, Light Weight, Security & Protection에 대해 각각 설명하고, 이 장점들이 현대 클라우드 네이티브 애플리케이션 개발 및 배포 환경에 어떤 긍정적인 영향을 미치는지 구체적인 사례를 들어 분석하시오.
3. Docker가 컨테이너 기술의 대중화에 결정적으로 기여할 수 있었던 요인들을 설명하고, Docker의 등장이 LXC, OCI, Kubernetes와 같은 다른 컨테이너 관련 기술 및 표준의 발전과 어떤 상호작용을 가졌는지 기술적 관점에서 논하시오.
4. 컨테이너와 가상머신(VM)은 각각 어떤 아키텍처와 특징을 가지며, 특정 상황에서 한 기술이 다른 기술보다 유리한 이유를 상세히 비교 설명하시오. 실제 IT 서비스 환경에서 두 기술의 적절한 활용 방안에 대해 자신의 견해를 제시하시오.
5. 컨테이너 보안 이슈(예: Dirty COW)와 같은 문제점들이 어떻게 발생했으며, 이러한 문제에 대응하기 위한 DevSecOps와 같은 새로운 접근 방식이 왜 중요해졌는지 설명하시오. 컨테이너 환경에서 보안을 강화하기 위한 전략들을 제시하시오.

## 5. 핵심 용어 용어집

- **컨테이너 (Container):** 애플리케이션 소프트웨어를 운영체제로부터 분리시켜 동작에 필요한 최소한의 실행 환경을 제공하는 샌드박스화된 런타임 환경.
- **샌드박스 (Sandbox):** 프로세스가 보호된 영역에서 동작하도록 하여 호스트 시스템에 대한 부정적인 영향을 방지하는 격리된 환경.
- **패키징 기술 (Packaging Technology):** 애플리케이션과 그 동작에 필요한 모든 라이브러리 및 환경을 독립적으로 묶어 배포 가능하게 하는 기술.
- **chroot (Change Root):** Unix V7에서 개발된 기술로, 프로세스의 루트 디렉터리를 변경하여 파일 시스템 접근을 제한하는 분리 기법.
- **FreeBSD Jail:** FreeBSD 시스템을 여러 개의 독립된 작은 시스템으로 분리하는 운영체제 수준의 가상화 기술.
- **Linux Vserver:** FreeBSD Jail과 유사하게 리눅스에서 CPU 시간, 메모리, 파일 시스템 등 시스템 리소스를 분리하는 운영체제 수준 가상화 기술.
- **Solaris Containers (Zone):** Solaris 운영체제에서 '존(zone)'이라는 개념을 도입하여 자원을 분리하고 프로세스 간 상호작용을 엄격하게 격리하는 기술.
- **cgroup (Control Group):** 리눅스 커널의 기능으로, CPU, 메모리, 디스크 I/O, 네트워크 등 컴퓨터 자원에 대한 프로세스의 사용량을 제한하고 우선순위를 제공하는 기술. (구 Google의 Process Container)
- **네임스페이스 분리 (Namespace Isolation):** 리눅스 커널의 기능으로, 프로세스 트리, 네트워킹, 사용자 ID, 마운트 파일 시스템 등 운영체제 환경을 애플리케이션 관점에서 분리하는 기술.
- **LXC (Linux Containers):** cgroup과 네임스페이스 분리 기술을 기반으로 하는 리눅스 운영체제 수준의 가상화 기술.
- **Docker:** LXC(초기), libcontainer(이후)를 활용하여 컨테이너를 쉽게 구축, 배포, 실행할 수 있도록 만든 오픈소스 플랫폼. "Build Once, Run Anywhere"라는 슬로건으로 컨테이너 보편화에 크게 기여.
- **Kubernetes:** Google에서 오픈소스로 공개한 컨테이너 오케스트레이션 툴로, 컨테이너화된 워크로드와 서비스를 관리하고 자동화하는 플랫폼.
- **CNCF (Cloud Native Computing Foundation):** 클라우드 네이티브 기술(컨테이너, 마이크로서비스 등)의 생태계를 구축하고 표준화하는 비영리 재단. Kubernetes 등을 관리.
- **Dirty COW (Copy-on-Write):** 2016년에 발견된 리눅스 커널의 보안 취약점으로, 레이스 컨디션을 이용하여 낮은 권한의 사용자가 읽기 전용 메모리에 쓰기 권한을 획득할 수 있게 하는 문제.
- **DevSecOps:** 개발(Development), 보안(Security), 운영(Operations)을 통합하는 소프트웨어 개발 접근 방식으로, 개발 초기 단계부터 보안을 개입시켜 시스템의 전체 수명 주기 동안 보안을 강화하는 것을 목표.
- **OCI (Open Container Initiative):** 컨테이너 이미지 포맷과 런타임에 대한 개방형 표준을 개발하기 위해 설립된 프로젝트 그룹.
- **CRI (Container Runtime Interface):** Kubernetes가 다양한 컨테이너 런타임과 상호 작용할 수 있도록 정의된 플러그인 인터페이스.
- **CRI-O:** OCI 기반의 경량 컨테이너 런타임으로, Kubernetes CRI 표준을 구현하여 Kubernetes 환경에서 컨테이너를 실행하는 데 최적화됨.
- **가상머신 (Virtual Machine, VM):** 호스트 시스템 위에 독립적인 운영체제와 하드웨어 환경을 에뮬레이션하여 여러 개의 가상 환경을 생성하는 기술.
- **클라우드 네이티브 애플리케이션 (Cloud Native Application):** 작고, 독립적이고, 상호 결합도가 낮은 서비스들의 모음으로 구성되며, 클라우드 환경의 장점을 최대한 활용하도록 설계된 애플리케이션.
- **모노리식 아키텍처 (Monolithic Architecture):** 애플리케이션의 모든 구성 요소가 하나의 단일 코드베이스로 긴밀하게 결합된 전통적인 소프트웨어 아키텍처.
- **멀티서비스 아키텍처 (Multiservice Architecture):** 애플리케이션을 작고 독립적인 여러 서비스(마이크로서비스)로 분할하여 개발하고 배포하는 아키텍처.