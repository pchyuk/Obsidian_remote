## 1. 개요 및 핵심 개념

이 스터디 가이드는 클라우드 컴퓨팅 환경에서 필수적인 CPU, 메모리, I/O 가상화 기술에 대한 이해를 돕기 위해 제작되었습니다. 각 가상화 기술의 작동 원리, 구현 방식, 장단점 및 관련 용어를 심도 있게 다룹니다.

## 2. CPU 가상화

### 2.1. 컴퓨터 시스템의 기본 구성 요소

- **CPU (Central Processing Unit):** 컴퓨터의 두뇌 역할을 하며, 프로그램의 명령어를 실행합니다.
- **메모리 (Memory):** CPU가 데이터를 빠르게 접근할 수 있도록 임시 저장 공간을 제공합니다.
- **I/O 장치 (Input/Output Devices):** 컴퓨터와 외부 세계 간의 정보 교환을 담당합니다 (예: 키보드, 마우스, 네트워크 카드).

### 2.2. 에뮬레이션

- **정의:** 서로 다른 ISA(Instruction Set Architecture)를 가진 컴퓨터 시스템에서 특정 ISA에 맞춰 개발된 소프트웨어를 다른 ISA 시스템에서 실행하기 위한 기술입니다.

1. **작동 방식 (ARM 에뮬레이터 예시):** ARM용 애플리케이션의 바이너리 이미지 스캐닝
2. ARM 명령어 추출 (opcodes extraction)
3. ARM 명령어를 x86 명령어로 변환 (translation)
4. x86에서 실행 (execution)

- **특징:** 이기종 시스템 간 ISA 번역으로 인해 성능 제약이 발생합니다. 동일한 ISA의 경우 변환 과정 없이 '직접 실행(direct execution)'이 가능하며, 컨테이너는 직접 실행의 한 종류입니다.

### 2.3. 특권 모드와 비특권 모드

- **보호 링 (Protected Ring):** 컴퓨터 시스템의 기능을 악성 동작이나 결함으로부터 보호하기 위해 권한을 계층적으로 구별하는 메커니즘입니다.
- **Ring 0:** 운영체제 커널이 위치하며, 메모리, CPU 하드웨어에 직접 접근합니다. '특권 모드'에 해당합니다.
- **Ring 1, 2:** (거의 사용되지 않음) 주로 디바이스 드라이버가 위치합니다.
- **Ring 3:** 사용자 애플리케이션이 위치합니다. '비특권 모드'에 해당합니다.
- **모드 스위칭 (Mode Switching):** 사용자 애플리케이션이 파일 읽기 등 특권 작업이 필요할 때 시스템 콜을 호출하여 사용자 모드에서 커널 모드(비특권 모드에서 특권 모드)로 전환하는 과정입니다.

### 2.4. 트랩 (Trap)

- **정의:** 비특권 모드의 게스트 OS가 특권 명령을 실행하려고 할 때 발생하는 이벤트입니다.
- **처리:** 트랩이 발생하면 하이퍼바이저가 이를 처리한 후 게스트 OS에 제어를 다시 넘깁니다.
- **문제점:** 트랩 처리는 하이퍼바이저에 부하를 증가시키며, 에뮬레이션할 수 없는 특정 명령(예: POPF)은 가상 머신의 불안정성을 초래할 수 있습니다. POPF 명령은 비특권 모드에서 ALU 플래그만 변경하도록 설계되었으나, 가상 환경에서 게스트 OS가 인터럽트 플래그를 수정하려 할 때 문제가 발생할 수 있습니다.

### 2.5. CPU 가상화 구현 기술

트랩 앤 에뮬레이션(Trap and Emulate) 방식의 문제점(오버헤드, 에뮬레이션 불가 명령)을 해결하기 위한 방법들입니다.

- **바이너리 트랜슬레이션 (Binary Translation) - VMWare:** 운영체제의 코드 이미지를 하이퍼바이저가 스캔하여 문제의 소지가 있는 명령어를 찾아 수정 후 실행 가능한 코드로 만듭니다.
- CPU에서 직접 실행하는 방식이지만, 하이퍼바이저의 번역 과정이 추가됩니다.
- **정적 바이너리 트랜슬레이션:** 모든 코드를 한 번에 타겟 CPU에 맞게 변환하여 속도가 빠르지만, 실제 실행 컨텍스트를 반영하지 못합니다.
- **동적 바이너리 트랜슬레이션:** 베이직 블록 단위로 변환을 진행하고 캐시에 저장하여 효율성을 높입니다.
- **문제점:** 코드 변환에 따른 오버헤드와 캐시 활용을 위한 추가 메모리 비용이 발생합니다.
- **하이퍼콜 (Hypercall) - Xen:** 반가상화(Paravirtualization)의 일종으로, 가상 머신의 운영체제 소스를 수정하여 문제의 소지가 있는 코드를 제거합니다.
- 하이퍼바이저를 직접 호출할 수 있는 Hypercall을 삽입하여 적절히 처리합니다. 코드 변환 및 트랩 처리 과정을 제거하여 성능을 개선합니다.
- **하드웨어적 지원 (VT-x, AMD-V):** 가상화 기능을 CPU에 직접 추가하여 효율성을 극대화합니다.
- 기존의 특권/비특권 모드 대신 루트 모드(Root Mode)와 비루트 모드(Non-Root Mode)로 구분하여 가상화를 지원합니다.

## 3. 메모리 가상화

### 3.1. 가상 메모리 (Virtual Memory)

- **정의:** 물리 시스템의 운영체제가 메모리를 관리하는 방식으로, 실제 물리 메모리보다 훨씬 큰 주소 공간(예: 64비트 시스템의 16EB)이 존재하는 것처럼 가상적으로 관리합니다.
- **작동 방식:** 메모리를 페이지(page) 단위로 관리하며 보조 기억장치(디스크)를 활용합니다.
- **MMU (Memory Management Unit):** 가상 주소(virtual address)를 물리 주소(physical address)로 변환하는 하드웨어 장치입니다. 빠른 변환을 위해 TLB(Translation Lookaside Buffer)라는 캐시를 사용합니다.
- **페이지 테이블 (Page Table):** 가상 주소와 물리 주소 사이의 매핑 정보를 저장합니다.

### 3.2. 가상화 환경에서의 메모리 변환

- **비가상화 환경:** 가상 주소 → 물리 주소
- **가상화 환경:** 가상 주소 → 가상 물리 주소 (Guest OS가 인지하는 물리 주소) → 머신 주소 (실제 물리 주소)
- 게스트 OS는 가상 환경을 인지하지 못하며, 가상 주소와 (자신이 생각하는) 물리 주소를 사용합니다. 하이퍼바이저가 이 (가상) 물리 주소를 실제 머신 주소로 변경하여 사용합니다.

### 3.3. TLB 에뮬레이션 방식 메모리 가상화

- **작동 방식:** TLB 미스 발생 시 페이지 테이블에서 매핑 정보를 찾고, 머신 주소가 존재하면 에뮬레이트된 TLB 페이지 테이블에 반영합니다. 머신 주소가 없으면 PMap(Physical Map)을 검색하고 필요 시 페이지를 로딩합니다.
- **문제점:** 가상 머신별 TLB 에뮬레이션 페이지 테이블 관리.
- 프로세스 컨텍스트 스위칭 시 페이지 테이블을 비워야 하는 오버헤드.
- **히든 페이지 폴트 (Hidden Page Fault):** 컨텍스트 스위칭으로 인해 TLB 에뮬레이션 페이지 테이블이 비워져서 게스트 페이지 테이블 간 정보가 불일치하여 발생하는 페이지 폴트입니다 (비가상화 환경에서는 발생하지 않음).
- **트루 페이지 폴트 (True Page Fault):** 페이지 테이블에서 매핑을 찾지 못하여 발생하는 일반적인 페이지 폴트입니다 (비가상화 환경에서도 발생).

### 3.4. TLB 에뮬레이션 문제점 해결 방안 (Software-assisted paging)

- **섀도우 페이지 테이블 (Shadow Page Table) 방식:** 프로세스별로 TLB 에뮬레이션 페이지 테이블(섀도우 페이지 테이블)을 관리하여 히든 페이지 폴트를 제거합니다.
- 성능 개선이 있으나, 많은 메모리를 사용하는 단점이 있습니다.
- **직접 페이지 테이블 접근 방식:** 반가상화 기반으로 게스트 OS를 수정하여 게스트 페이지 테이블을 머신 주소로 직접 수정합니다.
- 섀도우 페이지 테이블을 유지할 필요가 없어 메모리 낭비 및 동기화 문제를 제거합니다. Hypercall을 사용합니다.

### 3.5. 하드웨어 지원 페이징 (Hardware-assisted paging)

- **목적:** 소프트웨어 기반 메모리 가상화의 비효율성(특히 섀도우 페이지 테이블의 오버헤드)을 개선합니다. 전가상화 및 반가상화 모두 지원합니다.
- **기술:** AMD의 NPT(Nested Page Table), Intel의 EPT(Extended Page Table)가 유사하게 동작합니다.
- **작동 방식:** 가상 주소, 가상 물리 주소, 머신 주소 간의 매핑을 하드웨어적으로 처리합니다.
- 게스트 OS는 게스트 페이지 테이블을 사용하고, 하이퍼바이저는 중첩 페이지 테이블을 사용합니다.
- 중첩 페이지 테이블은 가상 머신당 존재하며, 게스트 페이지 테이블의 가상 물리 주소를 중첩 페이지 테이블을 통해 머신 주소로 변환합니다.
- 기존 5단계 메모리 접근에 중첩 페이지 테이블의 5단계가 추가되어 이론적으로 5 x 5 = 25번의 메모리 접근이 필요하지만, TLB 캐시를 적극적으로 사용하여 직접 메모리 접근 횟수를 줄입니다.
- **TLB 미스 감소 방안:Large Page Size:** 4KB보다 큰 페이지를 사용하여 엔트리 개수를 줄입니다.
- **Address Space ID (ASID):** 가상 머신 간 컨텍스트 스위칭 시 TLB 캐시를 비우는 대신, TLB 엔트리에 태그를 지정하여 특정 가상 머신에 할당함으로써 TLB 캐시를 비우지 않도록 합니다.

## 4. I/O 가상화

### 4.1. I/O 장치 및 가상화의 필요성

- I/O 장치는 CPU, 메모리와 함께 컴퓨터의 필수 구성 요소이며, 시스템 성능에 직접적인 영향을 미칩니다.
- 가상 환경에서 I/O 처리는 전체 시스템 성능의 주요 과제입니다.
- I/O 가상화는 물리 I/O 장치를 캡슐화하고, 가상 머신의 I/O가 물리 장치와 직접 통신하지 않고 간접적으로 통신하도록 분리하는 기술입니다.

### 4.2. I/O 가상화 방법 분류

- **소프트웨어적 I/O 가상화:** I/O 장치 에뮬레이션 (I/O Device Emulation)
- I/O 반가상화 (I/O Paravirtualization)
- 직접 접근 I/O (Direct Access I/O)
- 분리 드라이버 모델 (Split Driver Model)
- **하드웨어 지원 I/O 가상화:** IOMMU (I/O Memory Management Unit)
- SR-IOV (Single Root I/O Virtualization)

### 4.3. I/O 처리 방식 (비가상화 vs. 가상화)

- **비가상화:** I/O 장치에서 인터럽트 발생 → 인터럽트 컨트롤러가 CPU에 전달 → CPU가 작업 수행. MMIO(Memory Mapped I/O) 및 PIO(Programmed I/O)로 요청, 인터럽트 또는 DMA로 응답.
- **가상화:** 가상 머신에서 I/O 발생 → 하이퍼바이저에 전달 → 물리 I/O 장치 처리 → 하이퍼바이저가 결과 전달.

### 4.4. I/O 장치 에뮬레이션

- **정의:** I/O 장치를 소프트웨어적으로 구현하여 가상 머신이 이를 실제 장치로 인식하게 합니다.
- **특징:** 전가상화 방식이므로 게스트 OS 변경 불필요. 하이퍼바이저가 MMIO 및 PIO 명령을 트래핑하여 처리하고, 인터럽트 및 DMA도 에뮬레이션하여 처리합니다.
- **예시 (KVM):** 가상 머신은 QEMU 프로세스로 캡슐화되며, QEMU가 가상 I/O 장치에 대한 I/O 스레드를 생성하여 비동기 작업을 처리합니다.
- **단점:** 구현 난이도 및 오버헤드가 높습니다.

### 4.5. I/O 반가상화

- **정의:** 게스트 OS를 수정하여 I/O 관련 처리를 하이퍼바이저에게 직접 요청하도록 합니다. 게스트 OS와 하이퍼바이저 간 인터페이스(virtio 표준)가 정의됩니다.
- **구성:** 프런트엔드 드라이버(게스트 OS)와 백엔드 드라이버(하이퍼바이저)로 나뉩니다.
- **분리 드라이버 모델 (Split Driver Model):**I/O 반가상화에서 장치 드라이버를 하이퍼바이저가 아닌 별도의 특수 도메인(예: Xen의 Dom 0)에 위치시켜 관리합니다.
- 하이퍼바이저의 복잡성을 줄이고, 디바이스 드라이버의 유지보수 용이성을 높입니다. 게스트 OS는 Dom 0의 I/O 관련 API를 호출하도록 수정되어야 합니다.

### 4.6. 직접 접근 I/O (Passthrough I/O)

- **정의:** 특정 물리 I/O 장치를 특정 게스트 도메인 하나만 배타적으로 사용하도록 허용합니다. 하이퍼바이저의 중재 없이 게스트가 직접 디바이스와 통신하여 성능을 향상시킵니다.
- **특징:** 장치 에뮬레이션 및 프런트엔드/백엔드 통신 오버헤드 제거.
- **문제점:DMA (Direct Memory Access) 사용:** I/O 장치가 CPU 개입 없이 직접 메인 메모리에 접근하는 기능으로 성능 향상이 있으나, 메모리 보호 문제가 발생할 수 있습니다.
- **메모리 보호 문제:** 디바이스가 DMA를 통해 게스트 간 메모리 영역에 접근하여 데이터를 읽고 쓸 수 있어 보안 문제가 발생할 수 있습니다.
- **전가상화 지원 문제:** 전가상화 게스트 OS는 머신 주소를 알지 못하므로 올바른 DMA 요청을 할 수 없어 반가상화 환경에서만 가능했습니다.
- **디바이스 공유 문제:** 하드웨어 자원의 효율적 사용이라는 가상화의 기본 목표에 배치됩니다.

### 4.7. 하드웨어 지원 I/O 가상화

- 직접 접근 I/O의 단점을 극복하기 위한 기술입니다.
- **IOMMU (I/O Memory Management Unit):** CPU의 MMU와 유사하게 I/O DMA에 주소 변환 기능을 적용합니다 (DMA 리매핑).
- 전가상화 게스트 OS가 물리 주소를 전달하면 IOMMU가 이를 머신 주소로 변환하여 DMA 연산을 실행함으로써 전가상화를 지원합니다.
- 메모리 보호 기능을 제공하여 DMA 요청을 분리하고, 메인 메모리를 보호 도메인으로 나누어 I/O 장치에 접근 권한을 할당합니다.
- **SR-IOV (Single Root I/O Virtualization):** 하드웨어 기반 I/O 가상화 방식으로, 메모리 보호 기능을 갖는 직접 접근 I/O를 지원하면서 동시에 여러 가상 머신이 하나의 I/O 장치를 직접 접근할 수 있도록 합니다.
- 물리 I/O 장치(PCIe)를 여러 개의 가상 I/O 장치(PF: Physical Function, VF: Virtual Function)로 분리합니다.
- 하이퍼바이저는 PF를 제어하고, 가상 머신은 VF와 직접 통신합니다.

## 5. 퀴즈 (10문항)

각 질문에 대해 2-3문장으로 답하시오.

1. 에뮬레이션이란 무엇이며, 어떤 상황에서 주로 사용됩니까?
2. 컴퓨터 시스템의 보호 링(Protected Ring) 구조에서 Ring 0과 Ring 3의 주요 역할 차이는 무엇입니까?
3. POPF 명령어가 가상 머신 환경에서 불안정성을 야기할 수 있는 이유는 무엇입니까?
4. VMWare의 바이너리 트랜슬레이션(Binary Translation) 방식이 전가상화 방식임에도 불구하고 성능상 오버헤드가 발생하는 주된 원인은 무엇입니까?
5. 반가상화(Paravirtualization) 방식에서 하이퍼콜(Hypercall)이 사용되는 목적은 무엇이며, 이 방식의 주요 장점은 무엇입니까?
6. 가상화 환경에서 메모리 주소 변환이 비가상화 환경보다 복잡해지는 이유를 가상 주소, 가상 물리 주소, 머신 주소의 개념을 사용하여 설명하시오.
7. TLB 에뮬레이션 방식 메모리 가상화에서 발생하는 '히든 페이지 폴트'는 무엇이며, 이것이 '트루 페이지 폴트'와 다른 점은 무엇입니까?
8. I/O 장치 에뮬레이션 방식의 I/O 가상화가 가지는 두 가지 주요 단점은 무엇입니까?
9. 직접 접근 I/O(Direct Access I/O)가 디바이스 공유 문제와 전가상화 지원 문제를 가질 수 있었던 이유를 설명하시오.
10. IOMMU(I/O Memory Management Unit)가 기존 직접 접근 I/O의 어떤 문제점을 해결해주는지 두 가지 측면에서 설명하시오.

## 6. 퀴즈 정답

1. **에뮬레이션**은 서로 다른 ISA(Instruction Set Architecture)를 가진 시스템에서 특정 ISA에 맞춰 개발된 소프트웨어를 다른 ISA 시스템에서 실행하기 위한 기술입니다. 주로 ARM 기반 스마트폰 애플리케이션을 x86 기반 PC에서 개발하거나, 오래된 아케이드 게임을 최신 PC에서 실행할 때와 같이 이기종 환경에서 소프트웨어 호환성을 제공하는 데 사용됩니다.
2. **Ring 0**은 운영체제 커널이 위치하는 가장 높은 권한의 특권 모드로, CPU 하드웨어와 메모리에 직접 접근할 수 있습니다. 반면 **Ring 3**은 사용자 애플리케이션이 위치하는 가장 낮은 권한의 비특권 모드로, 하드웨어에 직접 접근할 수 없으며 시스템 콜을 통해서만 커널 기능에 접근할 수 있습니다.
3. POPF 명령어는 비특권 모드에서 ALU 플래그만 변경하도록 설계되었으나, 가상 환경에서 게스트 OS가 이 명령어를 통해 인터럽트 플래그를 수정하려 할 때 문제가 발생합니다. 게스트 OS의 인터럽트 금지 요구가 하이퍼바이저에 의해 무시될 수 있어 가상 머신의 불안정성을 초래할 수 있습니다.
4. 바이너리 트랜슬레이션은 게스트 OS를 수정하지 않고 운영체제 코드를 스캔하여 문제의 소지가 있는 명령어를 하이퍼바이저가 번역하여 실행합니다. 이 번역 과정 자체가 추가적인 연산 부하를 발생시키고, 성능 개선을 위해 캐시를 활용할 경우 추가 메모리 비용이 발생하기 때문에 오버헤드가 생깁니다.
5. 반가상화에서 **하이퍼콜**은 게스트 OS를 수정하여 I/O 관련 처리 등 특권 명령 처리를 하이퍼바이저에게 직접 요청하기 위해 사용됩니다. 이 방식의 주요 장점은 코드 변환 과정과 하이퍼바이저가 트랩을 처리하는 과정을 제거하여 전가상화 방식보다 성능 오버헤드를 줄일 수 있다는 점입니다.
6. 가상화 환경에서는 게스트 OS가 인지하는 '가상 주소'가 하이퍼바이저가 관리하는 '가상 물리 주소'로 변환되고, 다시 이 가상 물리 주소가 실제 하드웨어의 '머신 주소'로 변환됩니다. 이처럼 주소 변환 과정이 이중화되므로 비가상화 환경(가상 주소 → 물리 주소)보다 더 복잡해집니다.
7. '**히든 페이지 폴트**'는 가상화 환경에서 가상 머신별로 TLB 에뮬레이션 페이지 테이블을 관리하고, 프로세스 컨텍스트 스위칭 시 이 테이블이 비워지면서 게스트 페이지 테이블 간 정보 불일치로 인해 발생하는 페이지 폴트입니다. 반면 '**트루 페이지 폴트**'는 비가상화 환경에서도 발생하는 일반적인 페이지 폴트로, 페이지 테이블에서 매핑 정보를 찾지 못할 때 발생합니다.
8. I/O 장치 에뮬레이션 방식은 가상 머신이 실제 I/O 장치를 직접 사용하는 것처럼 느끼게 하지만, I/O 장치를 소프트웨어적으로 구현하기 때문에 구현 난이도가 높습니다. 또한, 하이퍼바이저가 게스트 OS의 MMIO 및 PIO 명령을 트래핑하고 인터럽트와 DMA를 에뮬레이션하는 과정에서 상당한 오버헤드가 발생합니다.
9. 직접 접근 I/O는 특정 I/O 장치를 하나의 게스트 도메인에 배타적으로 할당하여 사용하기 때문에 다른 가상 머신이 해당 장치를 사용할 수 없어 하드웨어 자원 공유라는 가상화의 기본 목표에 배치됩니다. 또한, 게스트 OS가 머신 주소를 알지 못하므로 DMA 명령을 올바르게 내릴 수 없어 전가상화 환경을 지원하기 어려웠습니다.
10. IOMMU는 첫째, DMA 리매핑 기능을 통해 전가상화 게스트 OS가 전달하는 물리 주소를 머신 주소로 변환하여 DMA 연산을 실행할 수 있도록 함으로써 **전가상화를 지원**합니다. 둘째, 메인 메모리를 보호 도메인으로 나누고 I/O 장치에 접근 권한을 할당하여 DMA 요청을 분리 처리함으로써 **메모리 보호 기능**을 제공합니다.

## 7. 에세이 형식 질문 (5문항)

1. CPU 가상화를 구현하는 세 가지 주요 기술(바이너리 트랜슬레이션, 하이퍼콜, 하드웨어적 지원)의 작동 원리, 각각의 장단점 및 적합한 가상화 시나리오를 비교 설명하시오.
2. 가상화 환경에서 메모리 주소 변환 과정이 비가상화 환경과 어떻게 다른지 상세히 설명하고, 이 과정에서 발생하는 TLB 에뮬레이션 방식의 문제점과 이를 해결하기 위한 소프트웨어적/하드웨어적 해결 방안들을 논하시오.
3. I/O 가상화의 필요성과 목적을 설명하고, 소프트웨어적 I/O 가상화 방식인 'I/O 장치 에뮬레이션'과 'I/O 반가상화'의 개념, 구현 방식 및 성능적 특징을 비교 분석하시오.
4. 직접 접근 I/O(Direct Access I/O) 방식이 I/O 성능 향상에 기여하는 측면과 함께, 이 방식이 야기하는 주요 문제점들을 상세히 설명하시오. 또한, 이러한 문제점들을 하드웨어적으로 해결하는 IOMMU와 SR-IOV 기술의 원리를 중심으로 설명하시오.
5. 전가상화(Full Virtualization)와 반가상화(Paravirtualization)의 개념을 CPU, 메모리, I/O 가상화 측면에서 각각 비교하고, 각 방식이 요구하는 게스트 OS 수정 여부, 성능 오버헤드, 구현 복잡성 등을 종합적으로 논하시오.

## 8. 핵심 용어 정의 (Glossary)

- **CPU 가상화 (CPU Virtualization):** 하나의 물리 CPU를 여러 개의 가상 CPU처럼 보이게 하여 여러 운영체제가 동시에 실행될 수 있도록 하는 기술.
- **메모리 가상화 (Memory Virtualization):** 물리 메모리를 가상화하여 여러 가상 머신이 독립적인 메모리 공간을 사용하는 것처럼 보이게 하는 기술.
- **I/O 가상화 (I/O Virtualization):** 물리 I/O 장치를 가상화하여 여러 가상 머신이 I/O 장치를 공유하거나 배타적으로 사용할 수 있도록 하는 기술.
- **에뮬레이션 (Emulation):** 한 컴퓨터 시스템이 다른 아키텍처의 시스템처럼 작동하도록 모방하여 해당 아키텍처용 소프트웨어를 실행하는 기술.
- **ISA (Instruction Set Architecture):** CPU가 이해하고 실행할 수 있는 명령어들의 집합.
- **직접 실행 (Direct Execution):** 별도의 명령어 변환 없이 CPU가 직접 명령어를 실행하는 방식.
- **보호 링 (Protected Ring):** 운영체제 및 애플리케이션의 권한 수준을 계층적으로 구분하여 시스템을 보호하는 메커니즘. Ring 0이 최고 권한.
- **특권 모드 (Privileged Mode):** 운영체제 커널처럼 하드웨어 자원에 직접 접근할 수 있는 높은 권한의 실행 모드. (Ring 0)
- **비특권 모드 (Unprivileged Mode):** 사용자 애플리케이션처럼 제한된 권한으로 실행되는 모드. (Ring 3)
- **모드 스위칭 (Mode Switching):** CPU의 실행 모드(특권/비특권)를 전환하는 과정.
- **트랩 (Trap):** 비특권 모드에서 특권 명령을 실행하려 할 때 발생하는 예외 상황. 하이퍼바이저가 이를 가로채서 처리.
- **하이퍼바이저 (Hypervisor):** 가상 머신을 생성하고 관리하는 소프트웨어 계층. 가상 머신 모니터(VMM)라고도 함.
- **바이너리 트랜슬레이션 (Binary Translation):** 게스트 OS의 바이너리 코드를 스캔하여 특권 명령 등을 하이퍼바이저가 인식하고 처리할 수 있는 코드로 변환하여 실행하는 전가상화 기술.
- **하이퍼콜 (Hypercall):** 반가상화 환경에서 게스트 OS가 하이퍼바이저에게 직접 서비스를 요청하기 위해 사용하는 특별한 함수 호출.
- **반가상화 (Paravirtualization):** 가상화 효율성을 높이기 위해 게스트 OS를 수정하여 하이퍼바이저와 협력하도록 하는 가상화 방식.
- **전가상화 (Full Virtualization):** 게스트 OS를 수정하지 않고 하드웨어 자원을 완전히 가상화하여 게스트 OS가 자신이 가상 환경에 있다는 것을 인지하지 못하게 하는 방식.
- **가상 메모리 (Virtual Memory):** 실제 물리 메모리보다 큰 주소 공간을 가상적으로 제공하며, 메모리를 페이지 단위로 관리하여 디스크를 보조 기억장치로 활용하는 기술.
- **MMU (Memory Management Unit):** 가상 주소를 물리 주소로 변환하는 하드웨어 장치.
- **TLB (Translation Lookaside Buffer):** MMU 내부의 캐시로, 최근에 변환된 가상 주소-물리 주소 매핑 정보를 저장하여 주소 변환 속도를 높임.
- **페이지 테이블 (Page Table):** 가상 주소와 물리 주소 간의 매핑 정보를 저장하는 자료구조.
- **가상 물리 주소 (Virtual Physical Address):** 가상화 환경에서 게스트 OS가 물리 주소라고 착각하는 주소. 하이퍼바이저에 의해 실제 머신 주소로 다시 변환됨.
- **머신 주소 (Machine Address):** 실제 물리 메모리의 주소.
- **히든 페이지 폴트 (Hidden Page Fault):** 가상화 환경에서 TLB 에뮬레이션 페이지 테이블과 게스트 페이지 테이블 간의 불일치로 인해 발생하는 페이지 폴트.
- **섀도우 페이지 테이블 (Shadow Page Table):** TLB 에뮬레이션 방식의 문제점을 해결하기 위해 프로세스별로 관리되는, 가상 주소-머신 주소 매핑 정보를 담는 테이블.
- **하드웨어 지원 페이징 (Hardware-assisted Paging):** 메모리 가상화의 오버헤드를 줄이기 위해 CPU에서 직접 메모리 주소 변환을 지원하는 기술 (예: Intel EPT, AMD NPT).
- **EPT (Extended Page Table):** Intel의 하드웨어 지원 페이징 기술.
- **NPT (Nested Page Table):** AMD의 하드웨어 지원 페이징 기술.
- **MMIO (Memory Mapped I/O):** I/O 장치의 레지스터를 메모리 주소 공간에 매핑하여 CPU가 일반적인 메모리 접근 명령으로 I/O 장치를 제어하는 방식.
- **PIO (Programmed I/O):** CPU가 I/O 장치의 특정 포트를 통해 직접 데이터를 읽고 쓰는 방식.
- **DMA (Direct Memory Access):** I/O 장치나 컨트롤러가 CPU 개입 없이 직접 메인 메모리에 접근하여 데이터를 읽고 쓰는 기능.
- **I/O 장치 에뮬레이션 (I/O Device Emulation):** I/O 장치를 소프트웨어적으로 구현하여 가상 머신이 실제 장치처럼 사용하게 하는 방식.
- **virtio:** 반가상화 I/O를 위한 표준 인터페이스. 프런트엔드/백엔드 드라이버 간 통신을 정의.
- **분리 드라이버 모델 (Split Driver Model):** I/O 반가상화에서 장치 드라이버를 하이퍼바이저가 아닌 별도의 특수 도메인(예: Xen의 Dom 0)에서 관리하는 방식.
- **직접 접근 I/O (Direct Access I/O) / 패스스루 I/O (Passthrough I/O):** 특정 물리 I/O 장치를 하나의 가상 머신에 배타적으로 할당하여 하이퍼바이저의 중재 없이 직접 통신하게 하는 방식.
- **IOMMU (I/O Memory Management Unit):** I/O 장치의 DMA 요청에 대해 주소 변환 및 메모리 보호 기능을 제공하는 하드웨어 장치. (Intel VT-d, AMD-Vi)
- **SR-IOV (Single Root I/O Virtualization):** 하나의 물리 I/O 장치(PCIe)를 여러 개의 가상 I/O 장치(VF)로 분할하여 여러 가상 머신이 직접 공유하여 사용할 수 있도록 하는 하드웨어 기반 가상화 기술.
- **PF (Physical Function):** SR-IOV에서 물리 I/O 장치를 대표하며 VF를 생성/관리하는 기능.
- **VF (Virtual Function):** SR-IOV에서 PF로부터 생성된 가상 I/O 장치로, 가상 머신에 할당되어 직접 통신 가능.