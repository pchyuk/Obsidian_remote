
# Today's Topics

### 가상 메모리 구현
- 페이징
- 분할

---
# Paging Introduction

![[3p.png]]

---
# Paging (1)

### 페이징
- 프로세스의 물리적 주소 공간이 연속되지 않도록 허용
- 물리적 메모리를 프레임이라는 고정된 크기의 블록으로 나눈다.
- 논리 메모리를 페이지라는 동일한 크기의 블록으로 나눈다.
  \- 페이지(또는 프레임) 크기는 2의 거듭제곱(일반적으로 512B ~ 8KB)이다.
  \- 현대 OS에서는 주로 4K를 사용한다.
- n페이지 크기의 프로그램을 실행하려면 n개의 빈 프레임을 찾고 프로그램을 로드해야 한다.
- OS는 모든 사용 가능한(빈) 프레임을 추적한다.
- 가상 주소를 물리적 주소로 변환할 페이지 테이블 설정

---
# Paging (2)

![[5p.png]]

페이지 테이블은 프로세스마다 하나씩 가지고 있다.

---
# Paging (3)

### 사용자 관점
- 사용자(및 프로세스)는 메모리를 0에서 N까지의 연속된 하나의 주소 공간으로 본다.
  \-Virtual address space(VAS, 가상 주소 공간)
- 실제로, 페이지는 물리적 메모리 전체에 흩어져 있다.
  \- 가상-물리적 매핑
  \- 이 매핑은 프로그램에서 볼 수 없다.
- 프로그램이 VAS 외부의 메모리를 참조할 수 없으므로 보호가 제공된다.
  \- 가상 주소 0xdeadcafe는 서로 다른 프로세스에 대해 서로 다른 물리적 주소로 매핑된다.

---
# Paging (4)

### 주소 변환
- 가상 주소는 두 부분으로 구성
  \- <가상 페이지 번호(VPN)::오프셋>
- VPN은 페이지 테이블의 인덱스이다.
- 페이지 테이블에서 페이지 프레임 번호(PFN)를 결정한다.
- 실제 주소는 <PFN::offset>

### 페이지 테이블
- OS에 의해 관리됨
- VPN을 PFN에 매핑
  \- VPN은 PFN을 결정하는 테이블의 인덱스
- 가상 주소 공간에서 페이지당 PTE(Page Table Entry) 1개, 즉 VPN당 PTE 1개 

---
# Paging (5)

### 주소 변환 아키텍처

![[3학년 1학기(24-1)/운영체제 필기노트/10.vm1/9p.png]]

---
# Paging (6)

### 페이징 예시

![[3학년 1학기(24-1)/운영체제 필기노트/10.vm1/10p.png]]

- 가상 주소 : 32비트(4G)
- 물리 주소 : 20비트(1M)
- 페이지 크기 : 4KB
- VPN : 20비트
- 페이지 테이블 엔트리: 2<sup>20</sup>

---
# Translation Using a Page Table

![[3학년 1학기(24-1)/운영체제 필기노트/10.vm1/11p.png]]

- Page table register는 현재 돌고 있는 프로세스들의 page table 주소(위치)를 갖고 있다.
- Valid Bit이 1이면 물리적 메모리에 데이터가 있는 것으로, 바로 메모리에 접근하고, Valid Bit이 0이면 찾는 데이터가 물리적 메모리에 없고 디스크에 있는 것이다.

---
# Paging (7)

### 페이지 테이블 항목(Page Table Entries, PTEs)

![[13p.png]]

- Valid bit(V) : PTE를 사용할 수 있는지의 여부를 나타냄
  \- 가상 주소를 사용할 때마다 확인된다.
- Reference bit(R) : 페이지에 액세스했는지 여부를 나타냄
  \- 페이지에 대한 읽기 또는 쓰기가 발생할 때 설정됨
- Modify bit(M) : 페이지의 더러움 여부를 나타냄
  \- 페이지에 대한 쓰기가 발생할 때 설정됨
- Protection bits(Prot) : 페이지에서 허용되는 작업(연산)을 제어함
  \- 읽기, 쓰기, 실행 등
- 페이지 프레임 번호(PFN)가 물리적 페이지를 결정한다.

---
# Paging (8)

### 보호(Protection)
- 메모리 보호는 각 프레임에 대한 보호 비트로 구현된다.
- 유효/잘못된 비트
  \- "Valid"는 관련 페이지가 프로세스의 가상 주소 공간에 있으므로 합법적인 페이지임을 나타냄.
  \- "Invalid"는 페이지가 프로세스의 가상 주소 공간에 없음을 나타냄
- 유효한 페이지에 대해 보다 세밀한 수준의 보호가 가능하다.
  \- 읽기 전용(Read-only)
  \- 읽기-쓰기(Read-write)
  \- 실행 전용(Execute-only)
---
# Mapping Pages to Storage

![[3학년 1학기(24-1)/운영체제 필기노트/10.vm1/14p.png]]

---
# Paging (9)

### 이점
- 물리적 메모리를 쉽게 할당할 수 있다.
  \- 물리적 메모리는 빈(free) 프레임 목록에서 할당된다.
  \- 프레임을 할당하려면 해당 빈(free) 목록에서 제거하기만 하면 된다.
- 외부 단편화 없음.(No external fragmentation)
  \- 물리적 메모리를 전부 페이지 사이즈만큼 잘라났기 때문
- 프로그램 덩어리를 "페이지 아웃"하기 쉬운 방법
  \- 모든 덩어리의 크기가 동일하다(페이지 크기)
  \- 유효한 비트를 사용하여 "페이지 아웃" 페이지에 대한 참조를 탐지한다.
  \- 페이지 크기는 일반적으로 디스크 블록 크기의 여러 배로 편리하게 선택된다.
- 불법 액세스로부터 페이지를 쉽게 보호
- 페이지를 쉽게 공유할 수 있다.

---
# Paging (10)

### 단점들
- 여전히 내부 단편화가 있을 수 있다.
  \- 프로세스가 정확한 여러 페이지의 메모리를 사용하지 않을 수 있다.
- 메모리 기준 오버헤드(성능 오버헤드)
  \- 주소 조회당 2개의 참조(페이지 테이블, 메모리)
  \- 해결책 : 하드웨어 지원(TLB) 받기
- 페이지 테이블을 유지하는 데 필요한 메모리는 클 수 있다.(공간 오버헤드)
  \- 가상 주소 공간에 페이지 당 하나의 PTE(Page Table Entry)가 필요하다.
  \- 32비트 주소 공간(4KB 페이지 포함) = 2<sup>20</sup> PTEs
  \- 페이지 테이블당 4bytes/PTE = 4MB
  \- OS에는 일반적으로 프로세스 당 별도의 페이지 테이블이 있다.
    (25개 프로세스 = 100MB의 페이지 테이블)
  \- 해결책 : 페이지 테이블, 멀티레벨 페이지 테이블, 반전 페이지 테이블 등
  
---
# Demand Paging (1)

### 요구 페이징(Demand Paging)
- 페이지가 필요할 때만 메모리로 가져오기
  \- 필요한 I/O 감소
  \- 필요한 메모리 감소
  \- 보다 빠른 응답
  \- 더 많은 사용자
- OS는 메인 메모리를 (페이지) 캐시로 사용
  \- 시스템의 프로세스에 의해 할당된 모든 데이터의 캐시
  \- 물리적 메모리가 가득 차면 교체(퇴거 및 부하)
- 제거된 페이지가 디스크로 이동
  \- 더러운 경우에 쓰기만 하면 된다.
  \- 디스크의 스왑 파일로 퇴거(evict)
  \- 메모리/디스크 간 페이지 이동은 OS(페이지 결함)에 의해 수행된다.
  \- 응용 프로그램(앱)에 대한 투명성(앱을 신경쓰지 않는다.)

---
# Demand Paging (2)

### 페이지 결함(Page faults)
- 삭제된 페이지의 가상 주소 참조
  \- 페이지가 제거되었을 때 OS는 PTE(Page Table Entry)를 유효하지 않은 것으로 설정
  \- 페이지 위치를 스왑 파일에 저장(PTE 단위)
  \- 페이지에 액세스하면 예외가 발생한다.
- OS가 페이지 장애 처리기를 실행
  \- 잘못된 PTE를 통해 스왑 파일에서 페이지를 찾는다.
  \- 핸들러가 페이지를 물리적 프레임으로 읽는다.
  \- PTE를 가리키고 유효하도록 업데이트한다.
  \- 핸들러가 장애가 발생한 프로세스를 다시 시작한다.
- 읽히는 페이지는 어디로 가는가?
  \- 다른 것을 퇴거(evict)해야 함 -> 어떤 것? -> 페이지 교체 알고리즘
  \- OS는 일반적으로 할당이 필연적으로 퇴거를 초래하지 않도록 사용 가능한 페이지 풀을 유지하려고 함

---
# Demand Paging (3)

![[20p.png]]

---
# Demand Paging (4)

### 이것이 작동하는 이유?
- 지역성(Locality)
  \- ==**시간 지역성(Temporal locality)**== : 최근에 참조된 위치는 곧 다시 참조되는 경향이 있다.
  \- ==**공간 지역성(Spatial locality)**== : 최근 참조된 위치 근처의 위치가 곧 참조될 가능성이 높다.
- 지역성은 페이징이 드물 수 있음을 의미한다.
  \- 일단 호출하면 여러 번 사용된다.
  \- 평균적으로 호출된 것을 사용한다.
  \- 그러나 이것은 여러 가지에 달려 있다.
    \* 적용 지역성 정도
    \* 페이지 교체 정책
    \* 물리적 메모리 양
    \* 애플리케이션의 참조 패턴 및 메모리 사용량

---
# Demand Paging (5)

### "수요(demand)" 페이징이 이루어지는 이유?
- ==**프로세스가 처음 시작되면**== 모든 PTE 유효 비트가 "false"인 완전히 새로운 페이지 테이블이 있다.
  \- **==모든 페이지가 비어 있다.==**
  \- 물리적 메모리에 아직 매핑된 페이지가 없다.
- 프로세스가 실행되기 시작할 때:
  \- 코드 페이지와 데이터 페이지 모두에 즉시 고장이 발생하는 지침
    \* 처음 프로세스가 실행되면 당연히 미스가 난다!(콜드 미스/콜드 페이지 고장)
  \- 필요한 모든 코드/데이터 페이지가 메모리에 있을 때 고장이 중지된다.
  \- 프로세스별로 필요한 코드/데이터(demanded(요구)!!)만 로드하면 된다.
  
![[22p.png]]

---
# Segmentation (1)

### 분할(Segmentation)
- **==메모리를 논리적으로 관련된 데이터 단위로 분할==**
  \- 코드, 스택, 힙 등
- 사용자는 메모리를 가변 크기 세그먼트의 집합으로 본다.
  \- 그 중에서 필요한 주문이 없는 경우
  \- 가상 주소 : <세그먼트 #::오프셋>
- 서로 다른 세그먼트는 독립적으로 성장하거나 축소할 수 있다.
  \- 서로에게 영향을 주지 않고
- 가변 크기 파티션의 자연스러운 확장
  \- 가변 크기 파티션 : 1 세그먼트/프로세스
  \- 세그먼트화(segmentation) : 많은 세그먼트/프로세스

---
# Segmentation (2~3)

### 사용자가 보는 프로그램의 모습

![[25p.png]]

원래는 "프로세스 단위" 로 메모리에 할당했지만, 세그먼트화(segmentation)는 프로세스의 각 부분별로 (논리적으로 관련된 데이터 단위) 모아놓는다.

---
# Segmentation (4)

### 하드웨어 지원
- 세그먼트당 하나씩 여러 개의 기본(base)/한계(limit) 쌍(Segment Table)
- 세그먼트 이름은 세그먼트 # 로 지정되며 표로 색인화하는 데 사용된다.

![[26p.png]]

---
# Segmentation (5)

### 이점
- 증가하거나 축소되는 데이터 구조의 처리를 단순화한다.
- **==세그먼트 보호에 유리하다.==**
  \- 세그먼트 테이블의 각 항목에 유효한 비트 연결
  \- 보호 비트(읽기/쓰기/실행)도 각 세그먼트 테이블 항목과 연결된다.
- **==세그먼트를 쉽게 공유할 수 있다.==**
  \- 기본(base)/한계(limit) 쌍에 동일한 변환을 입력한다. 
  \- 세그먼트 레벨에서 코드/데이터 공유 발생
  \- 예: 공유 라이브러리
  ![[27p.png]]

---
# Segmentation (6)

### 단점들
- **==교차 세그먼트 주소(Cross-segment address)==**
  \- 세그먼트에 대한 포인터를 프로세스 간에 공유하려면 세그먼트 번호가 동일해야 한다.
    (포인터가 세그먼트 밖을 가리키면 문제가 발생)
  \- 그렇지 않으면 간접 주소 지정만 사용한다.
- **==큰 세그먼트 표==**
  \- 메인 메모리에 보관하고, 하드웨어 캐시를 사용하여 속도를 높인다.
- **==외부 단편화(External fragment)==**
  \- 세그먼트의 길이가 다양하기 때문에 메모리 할당은 동적 스토리지 할당 문제이다.

---
# Paging vs. Segmentation (1~2)

![[29p.png]]
![[30p.png]]

---
# Paging vs. Segmentation (3)

###  하이브리드 접근법
- 페이징된 세그먼트
  \- **==페이징을 사용한 분할==**(Segmentation) - 세그먼트를 페이지로 쪼개기
  \- 세그먼트는 페이지 크기의 배수이다.
- 여러 페이지 크기
  \- IA32에서 4KB, 2MB, 4MB 페이지 크기 지원
  \- Alpha AXP 아키텍처에서 8KB, 16KB, 32KB 또는 64KB(43, 47, 51 또는 55비트 가상 주소)

---
# Segmentation with paging (1)

### 분할 및 페이징 결합
- 세그먼틀을 사용하여 논리적으로 관련된 단위 관리
  \- 코드, 데이터, 힙 등
  \- 세그먼트의 크기는 다양하지만 일반적으로 크기가 크다(여러 페이지)
- **==페이지를 사용하여 세그먼트를 고정된 크기의 덩어리로 분할==**
  \- 물리적 메모리 내에서 세그먼트를 보다 쉽게 관리할 수 있도록 한다.
  \- 세그먼트는 "페이지 가능(pageable)"으로 바뀐다.
    \* 세그먼트를 메모리 안팎으로 이동하는 대신 세그먼트의 페이지 부분만 이동한다.
  \- 외부 단편화(External fragmentation) 없음
- IA-32는 세그먼트 및 페이징을 지원한다.

---
# Segmentation with paging (2)

![[33p.png]]
