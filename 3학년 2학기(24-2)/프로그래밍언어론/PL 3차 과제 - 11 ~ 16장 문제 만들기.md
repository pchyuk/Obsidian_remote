# Chap 11. Boxes
## 1. 다음 두 표현식을 고려하여, interp 함수가 호출되는 순서를 설명하시오. 만약 오류가 발생한다면, 어느 부분에서 오류가 발생하는지 설명하시오
```scala
(λx.(λy.x+y)x) box 5
(λx.(λy.x∗y)(x+3)) box 2
```

### 해설
```scala
(λx.(λy.x+y)x) box 5
```
1. interp가 처음 호출되어 λx.(λy.x+y)가 인자로 전달되고, x에 5가 바인딩된다.
2. 다음으로 λy.x+y가 호출되며, 이때 x는 5로 바인딩된다.
3. y를 이용해 5+y를 평가한다. y는 아직 바인딩되지 않으므로 오류가 발생한다.

```scala
(λx.(λy.x∗y)(x+3)) box 2
```
1. interp가 처음 호출되어 λx.(λy.x∗y)가 인자로 전달되고, x에 2가 바인딩된다. (현재 상태: x=2)
2. 다음으로, λy.x∗y가 호출되며, x는 2로 바인딩된다.
3. y를 이용해 2 * (2 + 3)를 평가한다. 이 결과는 10이므로 10을 반환한다.

---
### + 추가 해설
```scala
(λx.(λy.x∗y)(x+3)) box 2
```
#### 초기 호출:
- interp 함수가 호출됩니다. 
- λx.(λy.x∗y)가 인자로 전달되고, x에 2가 바인딩됩니다.
- 현재 상태: x = 2
#### 첫 번째 함수 호출:
- 이제 내부 표현식인 (λy.x∗y)(x+3)가 평가됩니다.
- 이때, x + 3이 먼저 계산됩니다. 2 + 3의 결과는 5입니다.
- 현재 상태: x = 2, y는 아직 바인딩되지 않음.
#### 두 번째 함수 호출:
- 이제 λy.x∗y가 호출됩니다. 이때 y에 5가 바인딩됩니다.
- 현재 상태: x = 2, y = 5
#### 결과 계산:
- 이제 x * y를 계산합니다. 즉, 2 * 5가 됩니다.
- 최종 결과는 10입니다.

#### 바인딩 시점 요약
- x의 바인딩: 함수가 처음 호출될 때 x에 2가 바인딩됩니다.
- y의 바인딩: (x + 3)이 평가된 후, λy.x∗y가 호출될 때 y에 5가 바인딩됩니다.

---
## 2. 아래 코드를 완성하여 고정점 콤비네이터를 구현하라.
```scala
val w = λb.(
	val a = box λx.x in
	val f = b ??? in
	a = ???,
	f = w(λf.λv.if(v=0) 1 (v * f(v-1)))
)
```

### 해답
```scala
val w = λb.(
	val a = box λx.x in
	val f = b(a) in
	a = f,
	f = w(λf.λv.if(v=0) 1 (v * f(v-1)))
)
```

### 해설
- a는 자기 자신을 호출할 수 있는 함수로 설정되어야 한다.
- b는 고정점 콤비네이터를 이용하여 재귀 호출을 가능하게 한다.

---
# Chap 12. Mutable Variables
## 1. 아래 코드를 보고 최종 결과값을 답하시오.
```scala
val a = 10
val b = 20
val g = λx.λy.x * y
g(a)(b)
```

### 해설
1. g(a) 호출: g는 λy.10 * y로 평가된다.
2. b를 인자로 전달: 10 * 20 계산.
3. 최종 결과는 200

---
## 2. 아래 코드를 실행한 후의 최종 환경은 무엇인가?
```scala
val x = 2
val c1 = x := 3
val c2 = if0 x := 4 else skip
c1; c2
```

### 해설
1. 초기 환경: ∅
2. x := 2로 업데이트된 환경: {x -> 2}
3. c1 평가 (x := 3):
	- 업데이트된 환경: {x -> 3}
4. c2 평가 (if0 x := 4 else skip):
	- x의 값이 3이므로 else skip.
5. 최종 환경: {x -> 3}

---
# Chap 13. Garbage Collection
## 1. 아래 조건들을 보고, GC 후의 스택, From-space, To-space의 값을 구하시오
- 주어진 타입 태그는 다음과 같다.
	- 타입 태그 1: 정수 1개
	- 타입 태그 2: 정수 1개와 포인터 1개
	- 타입 태그 3: 포인터 1개와 정수 1개
	- 타입 태그 4: 포인터 2개
- 스택에 있는 포인터는 4 이다.
- From-space의 메모리 구조는 다음과 같다.

```scala
From-space: 2 3 4 5 6 7 8 9 10 11 12
```

### 해설
1. 스택: 4 (변경 없음)
2. From-space: 2 3 4 5 6 7 8 9 10 11 12 (변경 없음)
3. To-space:
	- 포인터 4가 가리키는 메모리 주소는 From-space의 5입니다.
	- From-space의 5는 타입 태그 1을 가리키며, 이 객체를 To-space에 복사합니다.
	- 이 과정에서 복사된 객체의 타입 태그를 99로 변경합니다.
4. 최종 결과:
	- 스택: 4
	- From-space: 2 3 4 5 6 7 8 9 10 11 12
	- To-space: 0 0 0 99 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

---
## 2. 스택에 있는 포인터는 7이다. From-space의 메모리 구조는 아래와 같다.

```scala
From-space: 1 2 3 4 5 6 7 8 9 10 11 12
```

