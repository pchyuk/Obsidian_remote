# Chap 11. Boxes
## 1. 다음 두 표현식을 고려하여, interp 함수가 호출되는 순서를 설명하시오. 만약 오류가 발생한다면, 어느 부분에서 오류가 발생하는지 설명하시오
```scala
(λx.(λy.x+y)x) box 5
(λx.(λy.x∗y)(x+3)) box 2
```

### 해설
```scala
(λx.(λy.x+y)x) box 5
```
1. interp가 처음 호출되어 λx.(λy.x+y)가 인자로 전달되고, x에 5가 바인딩된다.
2. 다음으로 λy.x+y가 호출되며, 이때 x는 5로 바인딩된다.
3. y를 이용해 5+y를 평가한다. y는 아직 바인딩되지 않으므로 오류가 발생한다.

```scala
(λx.(λy.x∗y)(x+3)) box 2
```
1. interp가 처음 호출되어 λx.(λy.x∗y)가 인자로 전달되고, x에 2가 바인딩된다. (현재 상태: x=2)
2. 다음으로, λy.x∗y가 호출되며, x는 2로 바인딩된다.
3. y를 이용해 2 * (2 + 3)를 평가한다. 이 결과는 10이므로 10을 반환한다.

---
### + 추가 해설
```scala
(λx.(λy.x∗y)(x+3)) box 2
```
#### 초기 호출:
- interp 함수가 호출됩니다. 
- λx.(λy.x∗y)가 인자로 전달되고, x에 2가 바인딩됩니다.
- 현재 상태: x = 2
#### 첫 번째 함수 호출:
- 이제 내부 표현식인 (λy.x∗y)(x+3)가 평가됩니다.
- 이때, x + 3이 먼저 계산됩니다. 2 + 3의 결과는 5입니다.
- 현재 상태: x = 2, y는 아직 바인딩되지 않음.
#### 두 번째 함수 호출:
- 이제 λy.x∗y가 호출됩니다. 이때 y에 5가 바인딩됩니다.
- 현재 상태: x = 2, y = 5
#### 결과 계산:
- 이제 x * y를 계산합니다. 즉, 2 * 5가 됩니다.
- 최종 결과는 10입니다.

#### 바인딩 시점 요약
- x의 바인딩: 함수가 처음 호출될 때 x에 2가 바인딩됩니다.
- y의 바인딩: (x + 3)이 평가된 후, λy.x∗y가 호출될 때 y에 5가 바인딩됩니다.

---
## 2. 아래 코드를 완성하여 고정점 콤비네이터를 구현하라.
```scala
val w = λb.(
	val a = box λx.x in
	val f = b ??? in
	a = ???,
	f = w(λf.λv.if(v=0) 1 (v * f(v-1)))
)
```

### 해답
```scala
val w = λb.(
	val a = box λx.x in
	val f = b(a) in
	a = f,
	f = w(λf.λv.if(v=0) 1 (v * f(v-1)))
)
```

### 해설
- a는 자기 자신을 호출할 수 있는 함수로 설정되어야 한다.
- b는 고정점 콤비네이터를 이용하여 재귀 호출을 가능하게 한다.

---



