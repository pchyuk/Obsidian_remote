## 4.1 First-Class Functions (1급 함수)
### 정의: First-Class Function은 다음을 충족하는 함수들이다.
- 함수의 인자로 사용될 수 있다.
- 함수의 반환값이 될 수 있다.
- 변수가 이를 참조할 수 있다.

### First-Class Function의 중요성
- First-Class Function은 프로그래밍에서 함수가 값을 가질 수 있도록 한다.
- 이는 곧 함수를 다른 데이터 타입과 동등하게 취급할 수 있음을 의미한다.
- 이를 통해 복잡한 계산을 쉽게 추상화할 수 있다.

```scala
def f(x: Int): Int = x
def g(h: Int => Int): Int = h(0)
assert(g(f) == 0) // g에 f를 인자로 전달
```
- g는 다른 함수 h를 인자로 받아서 실행하는 First-Class Function의 예시이다.

---
## 4.2 Annonymous Functions (익명 함수)
### 정의: 익명 함수는 이름이 없는 함수이다.
- 주로 람다 표현식으로 표현되며, 특정 작업을 수행하는 즉석에서 정의된 함수이다.

```scala
val double = (x: Int) => x * 2 // 익명 함수가 x를 매개변수로 받고 2배 반환

val h = (x: Int) => x // x를 입력으로 받아서 x를 반환하는 익명 함수
h(0) // 결과는 0
```

### 형식
```
([parameter name]: [parameter type], ...) =>[expression]
```

### 타입 추론
- Scala 컴파일러는 익명 함수가 필요할 때 자동으로 타입을 추론한다. 
- 따라서 복잡한 상황에서는 명시적인 타입 지정이 필요할 수 있다.

### 장점
- 코드의 간결성을 높이고, 함수를 전달할 필요가 없는 경우 유용하다.

---
## 4.3 Closures (클로저)
### 정의: 클로저는 자신이 정의될 때의 환경을 캡쳐하는 함수 값이다. 
- 이런 클로저는 정의된 시간의 변수 값을 기억하고 나중에 사용할 수 있게 한다.

### 예제
```scala
def makeAdder(x: Int): Int => Int = {
    def adder(y: Int): Int = x + y // x를 캡쳐하여 adder 함수에서 사용
    adder
}

val add1 = makeAdder(1)
assert(add1(2) == 3) // add1(2)는 1 + 2 = 3을 반환
```

### 작동 원리
- adder 함수는 x의 값을 참조하는데, 이는 makeAdder가 호출될 때의 x의 값이 무엇인지를 기억한다. 
- 따라서 add1은 x=1의 환경을 가진 채로 add2는 x=2 환경을 가진다.