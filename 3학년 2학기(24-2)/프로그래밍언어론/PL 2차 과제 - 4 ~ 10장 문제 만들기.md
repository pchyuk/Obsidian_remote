# Chap 4. Functions
## 1. 두 Int 리스트의 원소를 각각 더하는 함수를 작성하고, 결과를 출력하라.

```scala
def addLists(xs: List[Int], ys: List[Int]): List[Int] = {
    // fill this blank
}
```

---
### 해답
```scala
def addLists(xs: List[Int], ys: List[Int]): List[Int] = {
    (xs, ys) match {
        case (Nil, _) => ys
        case (_, Nil) => xs
        case (x::xt, y::yt) => (x + y) :: addLists(xt, yt)
    }
}
```

### 해설 
- 재귀 함수를 사용하여 두 리스트를 순회하면서 각 원소의 합을 리스트로 반환합니다. 
- 예를 들어, addLists(List(1, 2), List(3, 4))는 List(4, 6)을 반환합니다.

---
## 2. 클로저를 사용하여 함수가 호출될 때마다 값을 1씩 증가시키는 카운터를 구현하는 함수를 작성하라.

```scala
def counter(): /* fill this */ = {
    var count = 0
	// fill this blank
}
```

---
### 해답
```scala
def counter(): () => Int = {
    var count = 0
    () => {
        count += 1
        count
    }
}
```

---
### 해설
- 이 함수는 카운터를 생성하여 호출될 때마다 1씩 증가시키는 클로저를 반환합니다. 
- val countFunc = counter()로 카운터 함수를 생성한 후, countFunc()를 호출할 때마다 증가된 값을 반환합니다.

---
# Chap 5. Pattern Matching
## 1. 아래의 두 리스트가 같은지 확인하는 함수 equal을 작성하시오.
- 입력: 두 개의 Int형 리스트 l0와 l1
- 출력: 두 리스트가 동일하면 true, 아니면 false

---
### 해답
```scala
def equal(l0: List[Int], l1: List[Int]): Boolean =
  (l0, l1) match {
    case (h0 :: t0, h1 :: t1) => h0 == h1 && equal(t0, t1) // 1번째 줄
    case (Nil, Nil) => true // 2번째 줄
    case _ => false // 3번째 줄
  }
```

---
### 해설
- case (h0 : t0, h1 : t1): 두 리스트의 헤드가 같은지 비교합니다.
- case (Nil, Nil): 두 리스트가 둘 다 비어있는 경우입니다.
- case _ : 두 리스트가 다르거나 형태가 다른 경우입니다.

---
## 2. 정수 값을 이진 트리에 추가하는 함수 add를 작성하시오
- 입력: 트리 t와 정수 n
- 출력: 값을 추가한 새 트리

```scala
sealed trait Tree
case object Empty extends Tree
case class Node(root: Int, left: Tree, right: Tree) extends Tree

def add(/* fill this */): /* fill this */ =
  /*
	  fill this blank
  */
```

---
### 해답
```scala
sealed trait Tree
case object Empty extends Tree
case class Node(root: Int, left: Tree, right: Tree) extends Tree

def add(t: Tree, n: Int): Tree =
  t match {
    case Empty => Node(n, Empty, Empty)
    case Node(m, t0, t1) if n < m => Node(m, add(t0, n), t1)
    case Node(m, t0, t1) if n > m => Node(m, t0, add(t1, n))
    case _ => t
  }
```

---
### 해설
- case Empty: 빈 트리에 값을 추가하면 새로운 노드를 생성합니다.
- case Node(m, t0, t1) if n < m: 루트 값보다 작은 경우 왼쪽 서브트리로 재귀 호출합니다.
- case Node(m, t0, t1) if n > m: 루트 값보다 큰 경우 오른쪽 서브트리로 재귀 호출합니다.
- case _  이미 값이 존재하는 경우 원래 트리를 반환합니다.

---
# Chap 6. Syntax and Semantics
## 1. 아래의 코드 조각을 보고 어떤 내용이 유효한 표현인지 판단하고, 유효하지 않은 경우 그 이유를 설명하시오.

```scala
val a = 5
val b = { a + 10 }
val c = { if (a > 0) a else b }
val d = { +a }
```

---
### 해답/해설
#### 유효한 표현
- val a = 5
	- 정상적인 변수 정의입니다.
- val b = { a + 10 }
	- 대괄호 {} 안의 표현식은 정상적으로 평가되어 15를 반환합니다.
- val c = { if (a > 0) a else b }
	- 조건식이므로 c는 5로 평가됩니다.

#### 유효하지 않은 표현
- val d = { +a }
	+ 연산자는 부조회(positive)로 사용되는데, 이 표현은 특정 문맥에서만 유효합니다. 
	+ 단독으로 사용될 수 없습니다. 
	+ 오류가 발생하지는 않지만, 실제로는 부정적인 효과를 가지지 않으므로 구문적으로 의도한 바를 충족하지 못합니다.

---
## 2. 다음 중첩된 let 문장이 유효한지 판단하고, 오류가 난다면 어느 부분에서 오류가 발생하는지 설명하시오.

```scala
val x = 10 // 1
val y = { let { z = x + 5 } { z * 2 } } // 2
val z = { let { 5 = x + 5 } { y + z } } // 3
```

---
### 해답/해설
#### 유효성 판단
- let 문장의 사용은 아래와 같은 규칙을 따라야 합니다.
- `let { <var> <expression> } <body>` 형식을 지켜야 합니다.

#### 유효하지 않은 경우
- 3. let { 5 = x + 5 }
	- 변수 이름으로 숫자는 사용할 수 없습니다. 
	- 따라서 이 표현은 문법적으로 잘못되었습니다.
- 첫 번째 let은 유효하나 두 번째 let은 잘못된 구문이어서 전체적으로 오류가 발생합니다.

---
# Chap 7. Identifiers
## 1. 다음 코드에서 자유 식별자와 바운드된 식별자를 식별하고, 코드의 결과값을 답하시오.

```scala
var v1 = 10

def calculateSum(v2: Int): Int = {
    val v3 = 5
    v1 + v2 + v3
}

println(calculateSum(3))
```

---
### 해답/해설
- 바운드된 식별자: v2, v3
- 자유 식별자: v1

- v2는 함수의 매개변수로서 그 유효 범위는 함수 내에 제한되며, 
- v3은 함수 내부에서 정의된 지역 변수로서 그 유효 범위 또한 함수 내부입니다. 
- 반대로, v1는 함수 외부에서 정의되었으므로 자유 식별자로 간주됩니다. 

- calculateSum(3) 호출 시, 3 + 5 + 10의 결과인 18이 출력됩니다.

---
