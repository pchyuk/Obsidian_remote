# 15. Continuations
## Motivation
- 많은 실제 프로그래밍 언어가 제어 전환기(control diverter)를 지원한다.
	- 기본적으로, 표현식(expression)은 모든 하위 표현식(sub-expressions)이 평가된 후에만 평가(evaluated)된다.
	- break, continue, goto, throw와 같은 제어 전환기(control diverter)는 편리한 프로그래밍을 위해 다양한 방식으로 평가 흐름을 변경한다.(alters the flow of evaluations)

- MFAE에는 제어 전환기(control diverter) 기능이 없으며, 큰 단계 의미론(big-step semantics)은 이러한 제어 전환기를 표현하는 데 적합하지 않다.(is not suitable)
	- 제어 전환기(control diverter)는 실행 상태(status of execution)에 부수 효과(side-effect)를 주기 위한 것이다.

---
## Example: numOfWordsInFile
```scala
def numOfWordsInFile(name: String, word: String): Int = ...

// 캐시된 결과가 있는지 확인
def cached(name: String): Boolean 

// 캐시된 결과를 가져옴
def getCache(name: String): String 

// checks whether a given file exists 
def exists(name: String): Boolean 

// reads the content of the file and caches it 
def read(name: String): String 

// counts the number of occurrences of `word` in `content` 
def numOfWords(content: String, word: String): Int

def numOfWordsInFile(name: String, word: String): Int = { 
	val content = 
		if (cached(name)) 
			getCache(name) 
		else if (exists(name)) 
			read(name) 
		else 
			return -1 
	numOfWords(content, word) 
}

def numOfWordsInFile(name: String, word: String): Int = { 
	if (cached(name)) 
		numOfWords(getCache(name), word) 
	else if (exists(name)) 
		numOfWords(read(name), word) 
	else 
		-1 
}
```