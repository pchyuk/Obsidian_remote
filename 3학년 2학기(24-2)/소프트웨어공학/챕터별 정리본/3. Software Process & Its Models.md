## 다루는 주제
### 소프트웨어 프로세스 모델
- Waterfall (폭포수 모델)
- 진화적 모델 (프로토타이핑, 증분적)
	- Evolutionary (Rapid prototyping, Incremental)
- Agile 모델 (XP, Scrum)
- Transformation (변환)
- Sprial Model (나선형 모델)
- V model
- DevOps Model, ...

### 프로세스 특성별 SDLC 
### 소프트웨어 프로세스 표준: ISO 12207

---
## 여행 가자
### 최종 목적지까지 가는 방법은?
- 비행기 - 급하지만 돈이 많음
- 버스
- 자가용
- 기차
- 등등

### 거기에 무엇이 필요한가요?
- 시간
- 돈
- 친구
- 스마트폰
- 지도(스마트폰 없던 시절)

### 소프트웨어 개발은?
- 사용자 요구 사항 -> SW 시스템
- 필요한 것
	- 객체 지향 방법
- 사용자의 요구 사항이 완벽히 clear 하다면?
	- 요구 사항 분석이고 뭐고 필요 없음
	- 한 방에 해결

---
## 소프트웨어 개발 절차(프로세스)
- 소프트웨어 개발은 지속적인 절차적 활동
- 그 활동은 무엇일까?
- 소프트웨어 개발을 위한 다양한 경로를 어떻게 표현할 수 있을까?
	- 소프트웨어 프로세스 ==모델==
 ---
## 소프트웨어 프로세스 모델이란?
### 소프트웨어 생산 프로세스
- 소프트웨어 제품을 빌드, 전달, 배포 및 발전시기 위해 따르는 프로세스
- 아이디어의 시작부터 시스템의 전달 및 최종 폐기까지

### 생산과정의 목표 (Goal)
#### 고객의 기대에 부응한다.
- ***시간과 예산 내에서*** 고품질 제품을 제공함으로써
- 제품을 ***수익성 있게(profitable)*** 만들어서
- 생산을 ***안정적이고(reliable) 예측 가능하며(predictable) 효율적으로(efficient)*** 만들어서

### 소프트웨어 수명 주기 모델
- **요구사항 -> 분석 -> 설계 -> 코딩 -> (테스트) -> 배포 -> 운영 및 유지 관리 -> 퇴직**

---
## 프로세스 모델이 중요한 이유
### 블랙박스 프로세스
- 개발자가 뭐 하고 있는지 모름
- 피드백 불가

### 투명한(Transparent) 프로세스
- 피드백 가능
- 가시성(Visibility)

#### 출시 시간 단축 및 생산 비용 절감을 위해 프로세스는 제품 품질에 결정적인 영향을 미친다.

#### 프로세스를 제어함으로써 제품의 품질에 필요한 제어를 더 잘 달성할 수 있다.

---
## 소프트웨어 생산 활동
### 프로세스 (Process)
- 무엇을 해야 하는지에 대한 일련의(관련된) 단계

### 주요 활동 (Main Activities)
#### 1. 타당성, 실현 가능성(Feasibility) 조사
- 경제적
- 기술적 
	- 부족하면 아웃소싱 해야 함
		- 기술 유출
	- 자체 개발 = In-house SW
- 법률적으로 타당한가?(사행성 등)

#### 2. 유도, 이해 및 REQ 지정
#### 3. 소프트웨어 아키텍처 및 세부 설계
#### 4. 코딩 및 모듈 테스트
#### 5. 통합 및 시스템 테스트
#### 6. 배달, 배치 그리고 유지 관리

---
## 소프트웨어 프로세스 모델
### 소프트웨어 프로세스 모델
- 소프트웨어 개발 활동이 프로세스로 어떻게 구성될 수 있는지에 대한 표현

### 대표적 프로세스 모델
- 빌드 및 수정(코드 및 수정) 모델
- 폭포수 모델 (Waterfall Model)
- 진화 모델 (Evolutionary Model)
	- 신속한 프로토타입 제작 (Rapid prototyping)
	- 증분형 (Incremental)
- 변환 모델 (Transformation Model)
- 나선형 모델 (Sprial Model)
- 기타

---
## Build and Fix Model
### **일단 만들고 나중에 고친다.**
### 첫 번째 버전 빌드 : 코드 작성
### 수정 : 클라이언트가 만족할 때까지 수정

![[Pasted image 20241028221314.png]]

![[Pasted image 20241028221329.png]]

#### 주로 1인 개발할 때 사용
#### 명세(specification) 없이 제작
#### 규모 있는(reasonable) 제품에는 적합하지 않음
#### 오늘날의 환경에는 적합하지 않음
- 컴퓨터 지식이 없는 사람들을 위해 개발됨
- 더욱 엄격한(stringent) 신뢰성(reliability) 요구 사항
- 그룹 활동

---
## Waterfall Model (폭포수 모델)

![[Pasted image 20241028221555.png]]

![[Pasted image 20241028221630.png]]

### 1. 타당성, 실현 가능성 (Feasibility) 조사
### 2. 요구 사항 (Requirements)
- 수집 - 정의 - 분석
- 다음 단계로 넘어가는 방법?
	- PM Manager에 의해 결정
### 3. 설계 (Design)
### 4. 코딩 및 모듈 테스트
### 5. 통합 (Integration) 및 시스템 테스트
### 6. 배송, 배포 및 유지 관리 (Delivery, Deploy & Maintenance)

---
#### 1970년대부터 대중화된 산업 관행
#### 순차적, 단계 기반, 문서 지향
#### 한 단계의 출력은 다음 단계의 입력을 구성
#### 기여(Contribution)
- 엄격하고 계획적이며 관리 가능한 접근 방식 적용
- 제품 구현은 해당 목적을 충분히 이해한 후 연기하는 것이 좋다.

#### 문제점은?
### **단계를 거꾸로 올라갈 수 없다!**
- **요구 사항 수정 불가**

#### 많은 변형(Variants) 존재
- 피드백 루프를 갖춘 폭포수(Waterfall) 프로세스
- 증분형(incremental) 빌드를 사용한 폭포수 프로세스
- 등등
- ~~정처기에 나온다~~

---
## Evolutionary Model (진화 모델)
### 단계가 운영 소프트웨어 제품의 증분의 확장으로 구성된 모델
### 개발 전략
#### 전달 (Deliver)
- **실제 사용자에게** 무언가를
- 쿠팡!
#### 측정 (Measure)
- 모든 중요한 차원에서 사용자에게 추가된 가치
#### 조정 (Adjust)
- 관찰된 현실에 기반한 디자인과 목표 모두

### 유지 관리(Maintenance)는 수명 주기의 한 단계로 사라진다.
### 진화 모델의 두 가지 유형
1. 증분적(점진적) 접근 방식 (Incremental Approach)
2. 프로토타입 제작 (Prototyping)

---
## 1. Incremental Approach (점진적 접근)

![[Pasted image 20241028233633.png]]

![[Pasted image 20241028233647.png]]


### 1. 구현, 테스트, 첫 번째 빌드
- 각 빌드 하나하나는 폭포수 모델로 접근
### 2. 구현, 통합, 테스트, 두 번째 빌드
### 3. 연속 빌드...
### 4. 제품이 완성될 때까지 작업 모드

#### 단계적 개발 (Stepwise development)
#### 폭포수 모델에서 도입된 규율을 각 단계에서 유지 : *미니 폭포수 모델* 프로세스의 시퀀스

#### 장점 (Benefits)
- 사용자에게 새로운 제품에 적응할 수 있는 시간을 제공
- 변화에 쉽게 적응 가능
- 단계적 배송은 대규모 자본이 필요 x

#### 단점 (Problems)
- 빌드 및 수정 모델과 유사할 수 있음
- 각 통합 및 테스트의 오버헤드
	- 미니 프로세스 테스트 따로 통합한 것 또 따로 하려니까 비용이 많이 발생함.
- 사용자는 부분 시스템을 최종 시스템으로 간주할 수 있다.

---
## 2. (Rapid) Prototyping

![[Pasted image 20241028233951.png]]

![[Pasted image 20241028234005.png]]

### 두 번 개발
#### 첫 번째 버전(Throwaway prototype)
- 제품의 실현 가능성(feasibility)을 평가하위한 일회용(throwaway) 프로토타입
- 요구 사항을 확인하기 위해
#### 두 번째 버전(Evolutionary prototype)
- 폭포수 모델을 따른다.

### + 새로운 분류 방법
- Horizontal prototype
- Vertical prototype

### 프로토타입은 점차 최종 시스템으로 진화 가능

### 장점 (Benefits)
- 비용 및 시간 절감에 도움이 된다.
- 개발자 간, 개발자와 사용자 간의 커뮤니케이션을 개선한다.
- 오류를 조기에 감지하는 데 도움이 된다.

### 단점 (Problems)
- 변화를 예상할 필요성을 강조하지 않는다.

---
## 신속한 애플리케이션 개발 (RAD)
- Rapid Application Development
### Q: 소프트웨어를 빨리 개발하기 위한 방법?
- Tools (좋은 툴 사용)
- User involvement (사용자 참여)
	- 사용자와 같이 개발

### Q: 소프트웨어를 빨리 개발하는 이유?
- 시장에 최대한 빨리 내놓기 위해서
- Market 점유율이 곧 기업의 이익이기 때문문

---
### **빠른 개발 및 제공**은 지금은 종종 시스템의 가장 중요한 요구 사항이다.
- 기업은 빠르게 변화하는 요구 사항에 따라 운영되며 안정적인 소프트웨어 요구 사항 세트를 생성하는 것은 사실상 불가능하다.
- *소프트웨어는 변화하는 비즈니스 요구를 반영하기 위해 빠르게 발전해야 한다*.

### 급격한 소프트웨어 개발 속에서
- 사양(specification), 설계(design) 및 구현(implementation)은 서로 연결되어 있다.
- 시스템은 버전 평가에 이해관계자(stakeholders)가 참여하는 일련의 버전으로 개발된다.
- 사용자 인터페이스는 종종 IDE와 그래픽 도구 세트를 사용하여 개발된다.
- **Rapid Development -> Agile Development**
- **빠른 개발 -> 애자일 개발**

---
## 애자일 방법 (Agile Methods)
#### 같은 문제를 목표로 하는 대표적인 Agile 방법
- 신뢰할 수 있는 소프트웨어를 더욱 빠르게 만들 수 있다.

- 동적 시스템 개발 방법(데인 포크너 등)
- 적응형 소프트웨어 개발(짐 하이스미스)
- 크리스탈 클리어(방법의 가족, Alistair Cockburn)
- *XP(켄트 베크, 에릭 감마 등)*
- *Scrum (켄 슈와버, 제프 서덜랜드, 마크 비들)*
- Lean 소프트웨어 개발(Mary와 Tom Poppendieck)
- 기능 중심 개발(피터 코드와 제프 델루카)
- Agile 통합 프로세스(스콧 앰블러)

---
## XP Process
### 1990년대 Kent Beck의 eXtreme Programming
### 접근 방식 요구 사항 변경 처리

### 역할 및 책임
#### 프로그래머 (Programmer)
- 분석, 설계, 테스트, 코딩 및 통합
#### 관리자 (Manager)
- 프로젝트 프로세스 진행 상황을 제어
#### 고객 (Customer)
- 요구 사항 및 우선 순위

### 4가지의 가치를 추구
#### 의사소통 (Communication)
#### 간단 (Simplicity)
#### 피드백 (Feedback)
#### 용기 (Courage)
- 틀리더라도 말을 하는 게 낫다.

---
### XP에서의 12가지 실천 사항 (Practices)
#### 1. 계획 과정(점진적 계획, Planning process)
- 전체 시스템을 어떻게 나눌 것인가

#### 2. 소규모 릴리즈 (Small release)

#### 3. 은유 (Metaphor)
- 용어 사전(Term Dictionary)

#### 4. 단순한 디자인, 설계 (Simple design)
- 문서 최소화

#### 5. 지속적인 테스트 (Continuous testing)

#### 6. 리팩토링 (Refactoring)
- 재 구조화
- 클래스가 클 경우 쪼개는 것도 리팩토링

#### 7. 페어(Pair) 프로그래밍
- 짝
- ICPC 대회 생각. 
	- 눈 코딩. 다른 사람이 디버깅 해줌

#### 8. 집단 코드 소유권 (Collective code ownership)
- 모든 사람이 고칠 수 있다.

#### 9. 지속적인 통합 (Continuous integration)
- git

#### 10. 주 40시간 (40 hour week)
- 유지 가능한 페이스
- 번 아웃 방지
- 놓지마 정신줄!

#### 11. 현장(On-site) 고객
- 사용자가 현장에서 요구사항을 알려줘야 함

#### 12. 코딩 표준
- 코딩 규칙 정하기
- 예) 변수 이름 정하는 법
	- camel/pascal/snake case
- 국제적 코딩 표준 : MISRA
	- Motor industry(자동차)

---
## XP 프로세스 - 개발 주기

![[Pasted image 20241029001441.png]]

![[Pasted image 20241029001457.png]]

### 릴리스 주기
#### 1. 릴리스를 위한 **사용자 스토리** 선택
- ***누구***
- 왜 / 목적 / 어떻게 / 결과
- 규모 예측이 가능
#### 2. 스토리를 작업으로 분할
#### 3. 릴리스 계획
#### 4. 소프트웨어 개발 / 통합 / 테스트
#### 5. 소프트웨어 릴리스
#### 6. 시스템 평가
- 유저 피드백
#### 0. 다시 처음으로

### 개발(엔지니어링) 사이클
#### 1. 코딩
#### 2. 테스트
#### 3. 청취(Listening)
- User feedback / Peer review
#### 4. 설계
#### 0. 다시 처음으로

---
## Agile 방법 - Scrum
### 일반적인 애자일 방법이지만, 특정한 애자일 관행 이라기보다는 반복적인 관리를 함으로써 개발하는 것에 초점이 있다.

### By Jeff Sutherland and Ken Schwaber [Schwaber & Beedle 2002]

### Scrum 방법의 특징
#### **피드백 중심의 경험적 접근 방식**
- 모든 경험적 프로세스 제어와 마찬가지로 3가지 기둥(pillars)에 의해 뒷받침됨
	- 투명성 (transparency)
	- 검사 (inspection)
	- 적응 (adaptation)

#### Scrum 프레임워크 내의 모든 작업은 **결과에 대한 책임이 있는 사람들에게 보여야 한다.**
- 프로세스 (process)
- 작업 흐름 (workflow)
- 진행 상황 (progress)

#### 이러한 사항을 가시화 하려면 Scrum 팀이 개발 중인 제품과 팀의 **작업 능률을 자주 검사**해야 한다.
---
### Scrum의 3가지 단계
#### 초기 단계: **계획 단계 (Planning Phase)**
- 일반적인 목표를 확립하고 소프트웨어 아키텍처를 설계하는 단계
- 일반적인 계획, 기능 단위 구성도

#### 다음: 일련의 **스프린트 사이클 (Sprint cycle)**
- 각 주기가 시스템의 증가를 개발하는 곳

#### **폐쇄 단계(Closure Phase)**: 프로젝트 마무리
- 시스템 도움말 프레임, 사용자 매뉴얼 등 필수 문서를 완성하고, 프로젝트에서 얻은 교훈을 평가한다.

---
### 유물 (Artifacts, in sprint cycle)
#### 제품 백 로그 (Product Backlog)
- 우선순위를 갖는 요구 사항 목록
- Scrum 팀이 유지하는 요구 사항의 정렬된 제품의 목록

#### 스프린트 백 로그 (Sprint Backlog)
- 개발 팀의 작업 목록
- 개발 팀이 다음 스프린트에 처리해야 할 작업 목록

#### 제품 증가 (Product Increment)
- 또는 잠재적으로 배송 가능한 증가분, PSI
	- Potentially Shippable Increment
- 스프린트 동안 완료된 모든 제품 백 로그 항목의 합계

#### 번 다운 차트 (Burn-Down chart)
- **\ 모양**
- 남아있는 총 작업량을 나타내주는 그래프
- 세로축은 남은 작업량, 가로축은 시간을 나타냄
- 스프린트에서 남은 작업량을 보여주는 공개 차트
- 매일 업데이트 되는 백 로그
	![[Pasted image 20240926153818.png]]
#### + 번 업 차트 (Burn-Ip chart)
- **/ 모양**
- 완성도나 요구 사항 해결 수를 세로축으로 지정함
- 릴리스에 대한 진행 상황을 추적하는 방법

---
### 스크럼 프레임워크 (Scrum Framework)
![[Pasted image 20240926153936.png]]

#### Product Owner = 프로젝트 책임자
-  Product Backlog을 만들기 위한 미팅 진행
#### The Team = 개발자들
#### Sprint Planning Meeting
- Product Backlog들 중 어느 것을 Sprint Backlog에 넣을지 정하는 미팅
#### Daily Scrum Meeting
- 매일 진행(24시간마다)
- Sharing & Inspection
#### Scrum Master
- Sprint cycle을 진행하는데 있어 총 책임자
#### Sprint Retrospective
- 회고 미팅

---
## 변환 모델 (Transformation Model)
- 전환 모델 / 변환 모델
- 코드 자동 생성 (Code Auto-generation)

![[Pasted image 20240926154954.png]]

![[Pasted image 20240926154922.png]]

### Formal specification (공식적인 명세)
- Based Math (수학 기반)
### Varification 
- 검증, 확인

---
### 변환 모델 (Transforamtion Model)의 특징
#### 형식적 사양에 근거
- formal methods
- 세세한 예시는 안 다룬다
- 대학원 과정
#### 사양을 점차적으로 **구현으로 변환하는** 일련의 단계로 간주
#### 수동 및 자동으로
#### 연구 중심적 접근 방식 중 하나 (아마도)
#### 프로그램 정확성 증명 문제에 사용
#### 문제점
- 전문 지식이 필요하다
- 산업용으로 좁은 적용 범위

---
## 나선형 (Spiral) 모델

![[Pasted image 20241003140548.png]]

![[Pasted image 20241003140529.png]]

### 1. 목표, 대안, 제약 사항을 결정
### 2. 대안을 평가하고, 위험을 식별하고 해결
### 3. 개발 및 검증
### 4. 검토 및 약속, 다음 단계 계획
### 0. 다시 1번으로(1 phase 끝)

---
### By B. Boehm
### 메타(Meta) 모델
- 테이블의 형상
- 소프트웨어 생산 프로세스를 설계하기 위한 프레임워크 제공
- 현재 프로젝트의 **위험(risk) 수준**에 따라 안내됨
- **risk 얘기가 나오면? 무조건 Sprial 모델**

### 신중한 프로세스 설계를 통해 고위험 분석을 식별하고 제거하는 데 중점을 둔다.

### 문제점
- 각 나선형의 위험 분석으로 인해 **비용이 너무 많이 들 수 있다.**
- 적용 범위의 제한
- 대규모 소프트웨어 개발에만 사용 가능

---
## V 모델
### Verification & Validation
### Test-driven
- 모듈 단위로 테스트

![[Pasted image 20241003141645.png]]

![[Pasted image 20241003141701.png]]

### 1. Unit Test (단위 테스트)
- 함수의 파라미터가 잘 동작하는지 확인
### 2. Integration Test (통합 테스트)
- 파라미터끼리 잘 연결되는지 확인
### 3. System Test (시스템 테스트)
### 4. Acceptance Test (수용 테스트)

---
#### 검증(Verification) 및 확인(Validation) 모델로 알려짐
- **폭포수 모델의 확장**이며 각 해당 개발 단계에 대한 테스트 단계의 연관성을 기반으로 한다.

#### 장점
- 매우 엄격한 모델이며 각 단계가 한 번에 하나씩 완료됨
- **요구 사항이 잘 파악된 소규모 프로젝트**에 적합
- 간단하고 이해하기 쉬우며 사용하기 쉽다.

#### 단점
- **중간에 요구 사항이 변경될 위험이 높은 프로젝트**에는 적합하지 않다.
- **객체지향 프로젝트**와 **복잡한 모델**에는 적합하지 않다.

---
## CBSE 프로세스
- Component-Based Software Engineering Process
### 구성 요소 기반 소프트웨어 엔지니어링
### 1968년 Douglas Mcllroy와 함께 처음 알려짐
- 대량 생산된 소프트웨어 구성 요소

### Brad Cox가 1986년에 제시한 소프트웨어 구성 요소의 현대적 개념
- 소프트웨어 ICs

### CBSE 프로세스를 통한 개발

![[Pasted image 20241003143038.png]]

![[Pasted image 20241003143052.png]]

#### 1. 요구 사항 명세 - Use Case Diagram
#### 2. 요소 분석
#### 3. 요구 사항 수정
#### 4. 소프트웨어 설계 및 재사용
#### 5. 개발 및 통합
#### 6. 소프트웨어 검증

---
## DevOps
### **Dev**elopment + **Op**eration**s**
### ***고객이 원하는 요구사항을 얼마나 빨리 반영해줄 수 있는가?***
### DevOps의 중요 3요소
- **민첩성(agility)**
- **협업(collaboration)**
- IT 및 개발팀 프로세스 **자동화(automation)**

---
### 전통적인 소프트웨어 개발
#### 사일로(Silos) 접근 방식
- 사일로: 곡물 창고
- 한 번에 왕창?
- 요구사항이 다 끝나야 분석으로 넘어감

#### 각자의 팀과 프로세스에 따라 독립적으로 작업
- 각각의 작업이 단절되어 있다.
- **개발팀은 설계에 대한 생각을 하지 않는다.**

#### 오해 (miscommunication), 부적절한 정렬 (poor alignment), 생산 지연 (production delays)이 만연한 환경 ("작전실(War Room)")

---
### DevOps 목표
#### IT 운영과 개발 간의 격차 메우기
#### 소통과 협업 개선
#### 보다 원활한(seamless) 프로세스를 구축하고 전략과 목표 일치화
#### 더욱 빠르고 효율적인 배송

---
## DevOps란?
### DevOps의 개발-운영 라이프사이클

![[Pasted image 20241003144327.png]]

![[Pasted image 20241003144355.png]]
![[Pasted image 20241003144411.png]]

#### 1. 지속적인 통합 (Continuous Integration)
- Git
#### 2. 지속적인 배달 (Continuous Delivery)
#### 3. 지속적인 배포 (Continuous Deployment)
- OTA Property
- Over-The-Air
- 무선 업데이트
#### 4. 마이크로 서비스 아키텍처
#### 5. 코드 기반 인프라 (Code-based Infrastructure)
- Netflix
#### 6. 모니터링 및 로깅(Logging, 기록)

### 장점 (Benefits)
#### 1. 빠른 개발 및 빠른 릴리즈
#### 2. 테스트 자동화
#### 3. 빠르고 쉬운 업그레이드
#### 4. 협력 강화
#### 5. 보안 프로세스
- 사람의 개입이 줄어드니까 안전해짐

---
## DevOps의 툴체인
### 자동화는 핵심 중 하나이다.

![[Pasted image 20241003145349.png]]

---
## + 기타 프로세스 모델
#### Development Approach
#### AI-paired programming
- AI를 내 조수로
#### No-code / Low-code
- 코드 없이 / 코드 적게

![[Pasted image 20241003145612.png]]

---
## 프로젝트 특성별 SDLC
### Software Development Life Cycle
### 소프트웨어 개발 생명 주기

![[Pasted image 20241003150936.png]]

![[Pasted image 20241003150956.png]]

---
## 주요 출력 문서

![[Pasted image 20241003151026.png]]

![[Pasted image 20241003151042.png]]

---
## 소프트웨어 프로세스에 대한 표준

![[Pasted image 20241003151332.png]]

![[Pasted image 20241003151353.png]]

#### MIL-STD-498
#### ISO 9000 Series
#### ISO 15504* (SPICE)
- Level 1/2/3/4/5
- Level 3 이상
- A-SPICE
	- 자동차
#### CMMI

---
## ISO/IEC/IEEE 12207
### 목적 (Purpose)
#### 소프트웨어 수명 주기에 대한 공통 프레임워크를 확립(establish)하기 위해
- 소프트웨어를 취득, 공급, 개발, 운영 및 유지 관리하기 위해
- 프레임워크를 관리, 제어 및 개선하기 위해

### 참가자들
- 호주, 캐나다, 덴마크, 핀란드, 프랑스, 독일, 아일랜드, 이탈리아, 일본, 한국, 네덜란드, 스페인, 스웨덴, 영국, 미국

---
### 기본 개념 - 아키텍처

![[Pasted image 20241003152302.png]]

![[Pasted image 20241003152341.png]]

- PDCA : Plan-Do-Check-Action

---
### 기본 개념 - 프로세스(1995)
---
### 기본 개념 - 프로세스(2017)
---
## 레거시(Legacy) 소프트웨어 처리
### 동기 부여
#### 새로운 소프트웨어를 처음부터 개발하는 것은 불가능하다.
- 기존 소프트웨어 개발에 막대한 투자
#### 유산(Legacy) : 폐쇄하기 전에 매우 신중하게 보존해야 할 자산

### Re-engineering(Restructuring)
- 기존 시스템이 변형되어 새로운 형태로 재구성되는 과정

![[Pasted image 20241003152822.png]]

![[Pasted image 20241003152937.png]]

---
## 요약 및 토론
### 소프트웨어(생산 프로세스 모델)
- 폭포 (Waterfall)
- 진화적 (빠른 프로토타입 제작, 증분적)
- 변환 (Transformation)
- 나선형 (Sprial) 모델
- 에자일 (Agile) 모델
- DevOps 모델

### 왜 이러한 프로세스 모델이 필요할까?
### 프로세스 모델의 차이점은?
### 그리고 방법론은?