## 다루는 주제
### 소프트웨어 프로세스 모델
- Waterfall (폭포수 모델)
- 진화적 모델 (프로토타이핑, 증분적)
- Agile 모델(XP, Scrum)
- Transformation (변환)
- Sprial Model (나선형 모델)
- V model
- DevOps Model, ...

### 프로세스 특성별 SDLC 
### 소프트웨어 프로세스 표준: ISO 12207

---
## 여행 가자
### 최종 목적지까지 가는 방법은?
- 비행기 - 급하지만 돈이 많음
- 버스
- 자가용
- 기차
- 등등

### 거기에 무엇이 필요한가요?
- 시간
- 돈
- 친구
- 스마트폰
- 지도(스마트폰 없던 시절)

### 소프트웨어 개발은?
- 사용자 요구 사항 -> SW 시스템
- 필요한 것
	- 객체 지향 방법
- 사용자의 요구 사항이 완벽히 clear 하다면?
	- 요구 사항 분석이고 뭐고 필요 없음
	- 한 방에 해결

---
## 소프트웨어 개발 절차(프로세스)
- 소프트웨어 개발은 지속적인 절차적 활동
- 그 활동은 무엇일까?
- 소프트웨어 개발을 위한 다양한 경로를 어떻게 표현할 수 있을까?
	- 소프트웨어 프로세스 ==모델==
 ---
## 소프트웨어 프로세스 모델이란?
### 소프트웨어 생산 프로세스
- 소프트웨어 제품을 빌드, 전달, 배포 및 발전시기 위해 따르는 프로세스
- 아이디어의 시작부터 시스템의 전달 및 최종 폐기까지

### 생산과정의 목표 (Goal)
#### 고객의 기대에 부응한다.
- ***시간과 예산 내에서*** 고품질 제품을 제공함으로써
- 제품을 ***수익성 있게(profitable)*** 만들어서
- 생산을 ***안정적이고(reliable) 예측 가능하며(predictable) 효율적으로(efficient)*** 만들어서

### 소프트웨어 수명 주기 모델
- **요구사항 -> 분석 -> 설계 -> 코딩 -> (테스트) -> 배포 -> 운영 및 유지 관리 -> 퇴직**

---
## 프로세스 모델이 중요한 이유
### 블랙박스 프로세스
- 개발자가 뭐 하고 있는지 모름
- 피드백 불가

### 투명한(Transparent) 프로세스
- 피드백 가능
- 가시성(Visibility)

#### 출시 시간 단축 및 생산 비용 절감을 위해 프로세스는 제품 품질에 결정적인 영향을 미친다.

#### 프로세스를 제어함으로써 제품의 품질에 필요한 제어를 더 잘 달성할 수 있다.

---
## 소프트웨어 생산 활동
### 프로세스 (Process)
- 무엇을 해야 하는지에 대한 일련의(관련된) 단계

### 주요 활동 (Main Activities)
#### 1. 타당성, 실현 가능성(Feasibility) 조사
- 경제적
- 기술적 
	- 부족하면 아웃소싱 해야 함
		- 기술 유출
	- 자체 개발 = In-house SW
- 법률적으로 타당한가?(사행성 등)

#### 2. 유도, 이해 및 REQ 지정
#### 3. 소프트웨어 아키텍처 및 세부 설계
#### 4. 코딩 및 모듈 테스트
#### 5. 통합 및 시스템 테스트
#### 6. 배달, 배치 그리고 유지 관리

---
## 소프트웨어 프로세스 모델
### 소프트웨어 프로세스 모델
- 소프트웨어 개발 활동이 프로세스로 어떻게 구성될 수 있는지에 대한 표현

### 대표적 프로세스 모델
- 빌드 및 수정(코드 및 수정) 모델
- 폭포수 모델 (Waterfall Model)
- 진화 모델 (Evolutionary Model)
	- 신속한 프로토타입 제작 (Rapid prototyping)
	- 증분형 (Incremental)
- 변환 모델 (Transformation Model)
- 나선형 모델 (Sprial Model)
- 기타

---
## Build and Fix Model
### **일단 만들고 나중에 고친다.**
### 첫 번째 버전 빌드 : 코드 작성
### 수정 : 클라이언트가 만족할 때까지 수정

![[Pasted image 20241028221314.png]]

![[Pasted image 20241028221329.png]]

#### 주로 1인 개발할 때 사용
#### 명세(specification) 없이 제작
#### 규모 있는(reasonable) 제품에는 적합하지 않음
#### 오늘날의 환경에는 적합하지 않음
- 컴퓨터 지식이 없는 사람들을 위해 개발됨
- 더욱 엄격한(stringent) 신뢰성(reliability) 요구 사항
- 그룹 활동

---
## Waterfall Model (폭포수 모델)

![[Pasted image 20241028221555.png]]

![[Pasted image 20241028221630.png]]

### 1. 타당성, 실현 가능성 (Feasibility) 조사
### 2. 요구 사항 (Requirements)
- 수집 - 정의 - 분석
- 다음 단계로 넘어가는 방법?
	- PM Manager에 의해 결정
### 3. 설계 (Design)
### 4. 코딩 및 모듈 테스트
### 5. 통합 (Integration) 및 시스템 테스트
### 6. 배송, 배포 및 유지 관리 (Delivery, Deploy & Maintenance)

---
#### 1970년대부터 대중화된 산업 관행
#### 순차적, 단계 기반, 문서 지향
#### 한 단계의 출력은 다음 단계의 입력을 구성
#### 기여(Contribution)
- 엄격하고 계획적이며 관리 가능한 접근 방식 적용
- 제품 구현은 해당 목적을 충분히 이해한 후 연기하는 것이 좋다.

#### 문제점은?
### **단계를 거꾸로 올라갈 수 없다!**
- **요구 사항 수정 불가**

#### 많은 변형(Variants) 존재
- 피드백 루프를 갖춘 폭포수(Waterfall) 프로세스
- 증분형(incremental) 빌드를 사용한 폭포수 프로세스
- 등등
- ~~정처기에 나온다~~

---
## Evolutionary Model (진화 모델)
### 단계가 운영 소프트웨어 제품의 증분의 확장으로 구성된 모델
### 개발 전략
- (**실제 사용자에게** 무언가를) 전달 (Deliver)
	- 쿠팡!
- (모든 중요한 차원에서 사용자에게 추가된 가치) 측정
- (관찰된 현실에 기반한 디자인과 목표 모두) 조정

### 유지 관리(Maintenance)는 수명 주기의 한 단계로 사라진다.
### 진화 모델의 두 가지 유형
1. 증분적(점진적) 접근 방식
2. 프로토타입 제작

---
### 1. Incremental Approach (점진적 접근)
- 구현, 테스트, 첫 번째 빌드
	- 각 빌드 하나하나는 폭포수 모델로 접근
- 구현, 통합, 테스트, 두 번째 빌드
- 연속 빌드...
- 제품이 완성될 때까지 작업 모드

- 단계적 개발
- 폭포수 모델에서 도입된 규율을 각 단계에서 유지 : *미니 폭포수 모델* 프로세스의 시퀀스

#### 장점 (Benefits)
- 사용자에게 새로운 제품에 적응할 수 있는 시간을 제공
- 변화에 쉽게 적응 가능
- 단계적 배송은 대규모 자본이 필요 x

#### 단점 (Problems)
- 빌드 및 수정 모델과 유사할 수 있음
- 각 통합 및 테스트의 오버헤드
	- 미니 프로세스 테스트 따로 통합한 것 또 따로 하려니까 비용이 많이 발생함.
- 사용자는 부분 시스템을 최종 시스템으로 간주할 수 있다.

---
### 2. (Rapid) Prototyping
#### 두 번 개발
- 첫 번째 버전(Throwaway prototype)
	- 제품의 실현 가능성(feasibility)을 평가하위한 일회용(throwaway) 프로토타입
	- 요구 사항을 확인하기 위해
- 두 번째 버전(Evolutionary prototype)
	- 폭포수 모델을 따른다.

- 새로운 분류 방법
	- Horizontal prototype
	- Vertical prototype

#### 장점 (Benefits)
- 비용 및 시간 절감에 도움이 된다.
- 개발자 간, 개발자와 사용자 간의 커뮤니케이션을 개선한다.

#### 단점 (Problems)
- 변화를 예상할 필요성을 강조하지 않는다.

---
## 신속한 애플리케이션 개발
- Rapid Application Development(RAD)
#### 소프트웨어를 빨리 개발하기 위한 방법
- Tools (좋은 툴 사용)
- User involvement (사용자 참여)
	- 사용자와 같이 개발

#### 소프트웨어를 빨리 개발하는 이유
- 개발 시간 축소
- Market 점유 -> 기업의 이익

---
#### 빠른 개발 및 제공은 지금은 종종 시스템의 가장 중요한 요구 사항이다.
- 기업은 빠르게 변화하는 요구 사항에 따라 운영되며 안정적인 소프트웨어 요구 사항 세트를 생성하는 것은 사실상 불가능하다.
- 소프트웨어는 변화하는 비즈니스 요구를 반영하기 위해 빠르게 발전해야 한다.

#### 급격한 소프트웨어 개발 속에서
- 사양(specification), 설계(design) 및 구현(implementation)은 서로 연결되어 있다.
- 시스템은 버전 평가에 이해관계자(stakeholders)가 참여하는 일련의 버전으로 개발된다.
- 사용자 인터페이스는 종종 IDE와 그래픽 도구 세트를 사용하여 개발된다.
 - *Rapid Development -> Agile Development*

---
## Agile Methods
##### 같은 문제를 목표로 하는 대표적인 Agile 방법
- 신뢰할 수 있는 소프트웨어를 더욱 빠르게 만들 수 있다.

- 동적 시스템 개발 방법(데인 포크너 등)
- 적응형 소프트웨어 개발(짐 하이스미스)
- 크리스탈 클리어(방법의 가족, Alistair Cockburn)
- *XP(켄트 베크, 에릭 감마 등)*
- *Scrum (켄 슈와버, 제프 서덜랜드, 마크 비들)*
- Lean 소프트웨어 개발(Mary와 Tom Poppendieck)
- 기능 중심 개발(피터 코드와 제프 델루카)
- Agile 통합 프로세스(스콧 앰블러)

---
## XP Process
- 1990년대 Kent Beck의 eXtreme Programming
- 접근 방식 요구 사항 변경 처리

#### 역할 및 책임
- 프로그래머: 분석, 설계, 테스트, 코딩 및 통합
- 관리자: 프로젝트 프로세스 진행 상황을 제어
- 고객: 요구 사항 및 우선 순위

#### 4가지의 가치를 추구
- 의사소통(Communication)
- 간단(Simplicity)
- 피드백(Feedback)
- 용기(Courage)
	- 틀리더라도 말을 하는 게 낫다.

#### XP에서의 12가지 실천 사항(Practices)
- 계획 과정(점진적 계획)
	- 전체 시스템을 어떻게 나눌 것인가
- 소규모 릴리즈
- 은유(Metaphor)
	- 용어 사전(Term Dictionary)
- 단순한 디자인(설계)
	- 문서 최소화

- 지속적인 테스트
- 리팩토링(Refactoring)
	- 재 구조화
	- 클래스가 클 경우 쪼개는 것도 리팩토링

// 여기까지 설명하심
// 여기부터 0926

- 페어(Pair) 프로그래밍
	- 짝
	- ICPC 대회 생각. 
		- 눈 코딩. 다른 사람이 디버깅 해줌
- 집단 코드 소유권
	- 모든 사람이 고칠 수 있다.

- 지속적인 통합
	- git
- 주 40시간(유지 가능한 페이스)
	- 번 아웃 방지
	- 놓지마 정신줄!
- 현장(On-site) 고객
	- 사용자가 현장에서 요구사항을 알려줘야 함
- 코딩 표준
	- 코딩 규칙 정하기
	- 예) 변수 이름 정하는 법
		- camel/pascal/snake case
	- 국제적 코딩 표준 : MISRA
		- Motor industry(자동차)