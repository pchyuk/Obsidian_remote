
# Today's Topics

### 왜 메모리를 관리하는 것이 어려운가?

### 오래된 메모리 관리 기법
1. 고정 파티션(Fixed)
2. 가변 파티션(Variable)
3. 스와핑(Swapping)

### 가상 메모리에 대한 소개

---
# Memory Management (1)

## Goals
- 프로그래밍에 편리한 추상화를 제공하기 위해
- 부족한 메모리 자원을 경쟁 프로세스 간에 할당하기 위해
  \- 최소한의 오버헤드로 성능 극대화
- 프로세스 간에 메모리들을 격리시키기 위해서

### 왜 그렇게 어려운가?

---
# Single/Batch Programming

### 하나의 사용자 프로세스를 가진 OS
- 프로그램은 물리적 주소를 직접 사용한다.
- OS에서 작업을 로드하고, 실행하고, 언로드한다.

![[4p.png]]

---
# Multiprogramming

## Multiprogramming

-  한 번에 여려 프로세스를 메모리에 저장해야 함
   \- 여러 작업의 I/O 및 CPU를 겹치려면
   \- 각 프로세스에는 가변 크기의 연속 공간이 필요하다.
-  요구사항
   \- 보호 : 사용할 수 있는 주소 및 프로세스 제한
   \- 빠른 번역 : 메모리 검색은 보호를 받더라도 빨라야 한다.

### 가상 주소(앱 관점) <-> 물리적 주소(커널별로 관리) 

---
# Fixed Partitions (1)

![[6p.png]]

---
# Fixed Partitions (2)

### 물리적 메모리는 고정된 파티션으로 분할

- ==**각 파티션의 크기는 동일**==하고 고정되어 있다.
- 파티션 수 = 멀티 프로그래밍의 정도
  \- 한 번에 돌릴 수 있는 프로세스의 개수가 한정되어 있다.
- 하드웨어 요구사항: 기본 레지스터
  \- 물리적 주소 = 가상 주소 + 기본 레지스터
  \- 프로세스로 전환할 때 OS가 로드하는 기본 레지스터

### 이점
- 구현이 쉽고, 컨텍스트 스위칭이 빠르다.

### 문제점
- 내부 단편화(Internal fragmentation)
  \- 프로세스에서 사용되지 않는 파티션의 메모리를 다른 프로세스에서 사용할 수 없다.
- 파티션 크기: 한 사이즈가 모든 프로세스에 맞는 것은 아니다.
  \- 단편화 vs 대형 프로그램 피팅

---
# Fixed Partitions (3)

### 개선점
- ==파티션의 크기가 모두 같을 필요는 없다.==
- 첫 번째 적합 할당(First fit allocation)
  \- 빈 파티션에 크기가 맞는 가장 가까운 작업에 할당
  \- 스캔 필요
- 최적 적합 할당(Best Fit allocation)
  \- 빈 파티션에 가장 큰 작업 선택
  \- 더 많는 검색 필요(오버헤드 증가)
- IBM OS/MFT(고정된 작업 수를 사용한 멀티프로그래밍)

---
# Variable Partitions (1)

![[9p.png]]

---
# Variable Partitions (2)

### 물리적 메모리는 가변 크기의 파티션으로 분할
- IBM OS/MVT
- 하드웨어 요구사항 : 베이스 레지스터 및 리미트 레지스터
  \- 물리적 주소 = 가상 주소 + 기본 레지스터
  \- 프로세스로 전환할 때 OS가 로드하는 기본 레지스터
- 리미트 레지스터의 역할 : 보호 
  \- 물리적 주소 > base + limit인 경우 보호 결함(protection fault)을 발생시킨다.
- 할당 전략
  \- 첫 번째 맞춤(First Fit) : 충분히 큰 첫 번째 홀을 할당
  \- Best Fit : 충분히 큰 가장 작은 홀을 할당
  \- Worst Fit : 가장 큰 홀을 할당

---
# Variable Partitions (3)

### 이점
- 내부 단편화(Internal fragmentation) 없음
  \- 단순히 프로세스에 맞게 파티션 크기를 할당하기만 하면 됨

### 문제점
- 외부 단편화(External fragmentation)
  \- 작업을 로드하고 언로드할 때 물리적 메모리에 구멍이 흩어져 있다.
- 외부 단편화에 대한 해결책:
  \- 압축(Compaction)
  \- 호출 및 분할(Paging and segmentation)

---
# Overlays (1)
## two-pass 어셈블러에 대한 오버레이

![[12p.png]]
한 공간에 2개의 코드를 썼다 지웠다 한다.
과거에 사용했던 방식, 현재는 잘 쓰지 않는다.

---
# Overlays (2)

## Overlays
- 특정 시간에 필요한 지침과 데이터만 기억
- 일반적으로 사용자에 의해 구현됨

### 이점
- 프로세스에 할당된 메모리의 양보다 큰 경우 필요
- **운영 체제의 특별한 지원이 필요하지 않음**

### 문제점
- 복잡하다
  \- 오버레이 구조의 프로그램 설계

---
# Swapping (1)

![[14p.png]]
요즘 개념과는 다름. 과거얘기

---
# Swapping (2)

## Swapping
- 일시적으로 메모리에서 백업 저장소로 스왑
- 계속 실행하기 위해 나중에 메모리로 다시 가져오기
- 백업 스토어
  \- 빠른 디스크
  \- 모든 메모리 이미지의 복사본을 수용할 수 있는 크기
  \- 이러한 메모리 이미지에 직접 액세스해야 함

### 문제점
- 스왑 시간의 주요 부분은 전송 시간(transfer time)이다.
  \- 스왑된 메모리 양에 정비례
- 보류중인 I/O와 프로세스를 교환?
  \- 보류중인 I/O와 프로세스를 스왑하지 않음
- ==최신 OS는 가상 메모리와 수정된 스왑 메커니즘(요구 페이징, demand paging)을 사용한다.==
  
---
# Virtual Memory (1)

![[16p.png]]

두 명의 사용자가 동시에 이 응용 프로그램을 실행하면 어떻게 될까?
-> &n으로 출력되는 주소는 가상 주소이다. 그렇기 때문에 다시 컴파일하지 않는다는 가정 하에 가상 주소는 같다.

---
# Virtual Memory (2)

### 가상 메모리(VM)
- 메모리 참조에 ==가상 주소== 사용
  \- 크고 연속적이다.(Large and contiguous)
- CPU 및 OS가 실행 시간에 주소 변환을 수행한다.
  \- 가상 주소에서 해당 물리적 주소로
- 물리적 메모리가 ==요구에 따라== 동적으로 할당되거나 해제
  \- 전체 주소 공간이 물리적 메모리에 상주하지 않아도 프로그램이 실행
  \- Lazy loading
- ==가상 주소는 각 프로세스에 대해 비공개==이다.
  \- 각 프로세스에는 고유한 분리된 가상 주소 공간이 있다.
  \- 한 프로세스에는 다른 프로세스가 볼 수 있는 주소의 이름을 지정할 수 없다.

---
# Virtual Memory (3)

### 가상 주소
- 여러 프로세스의 메모리를 쉽게 관리할 수 있도록 프로세스에서 가상 주소(논리 주소)를 사용하도록 한다.
- 가상 주소는 참조된 데이터의 실제 물리적 위치와 독립적이다.
- OS는 물리적 메모리에서 데이터의 위치를 결정한다.

### 메모리 액세스 절차
- CPU가 가상 주소를 발행하여 실행하는 명령어
- 하드웨어에 의해 가상 주소가 물리적 주소로 변환된다.(OS의 도움을 받아서)
- 가상 주소 공간: 프로세스에서 사용할 수 있는 가상 주소 집합

### 가상 주소를 물리적 주소로 변환하는 여러 가지 방법이 있다.

---
# Virtual Memory (4)

### 이점
- 사용자의 가상 메모리(논리 메모리)와 물리적 메모리를 분리한다.
  \- 메인 메모리를 매우 크고 균일한 스토리지 배열로 추상화
  \- 프로그래머가 메모리-스토리지 제한에 대한 우려로부터 자유로워진다.
- 프로그램은 물리적 메모리보다 큰 VAS(가상 메모리)를 사용할 수 있다.
  \- 메모리에 완전히 없을 수도 있는 프로세스를 실행할 수 있다.
- 더 많은 프로그램을 동시에 실행할 수 있다.
- 필요한 I/O 감소(페이지 스와핑 포함)
  \- 각 사용자 프로그램을 메모리에 로드하거나 교환한다.
- 프로세스가 파일 및 주소 공간을 쉽게 공유할 수 있도록 한다.
- 보호 및 프로세스 생성에 효율적이다.

---
# Virtual Memory (5)

### 단점
- 성능!!
  \- 시간적, 공간적 측면에서

### 구현
- 페이징(Paging)
- 분할(Segmentation)

