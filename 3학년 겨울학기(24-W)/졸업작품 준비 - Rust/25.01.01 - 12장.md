### 커맨드 라인 인수 받기
- 언제나처럼 `cargo new` 를 사용해서 새 프로젝트를 만든다.
- 새 프로젝트의 이름은 `minigrep` 이다.

```shell
$ cargo new minigrep 
	Created binary (application) `minigrep` project 
$ cd minigrep
```

- minigrep 프로젝트: 2개의 커맨드라인 인수를 받는다.
	- 검색할 파일 경로, 문자열
	- cargo run 대신 프로그램 사용을 위한 인수가 나올 것임을 알려주는 두 개의 하이픈(--), 검색을 위한 문자열, 그리고 검색을 원하는 파일 이름

``` shell
$ cargo run -- searchstring example-filename.txt
```

- 현재 `cargo new` 로 생성한 기본 프로그램은 입력한 인수를 처리할 수 없다.
- crates.io에 있는 라이브러리를 사용하면 인수를 받는 프로그램 작성에 도움이 되겠지만, 지금은 배우는 단계이므로 직접 기능을 구현해 보자.

### 인수 값 읽기
- `minigrep` 프로젝트가 위의 커맨드 라인 인수로 전달된 값을 읽을 수 있도록 하기 위해서는 러스트의 표준 라이브러리가 제공하는 `std::env::args` 함수를 사용해야 한다.
	- 이 함수는 프로젝트로 넘겨진 커맨드 라인 인수의 반복자(iterator)를 반환한다.
	- 반복자에 대한 자세한 설명은 13장에서 공부한다.
	- 지금 반복자에 대해 알아야 할 2가지 세부사항
	- 1. 반복자는 일련의 값을 생성한다.
	- 2. 반복자의 `collect` 메서드를 호출하여 반복자가 생성하는 모든 요소를 담고 있는 벡터 같은 컬렉션으로 바꿀 수 있다.

```rust
// 예제 12-1: 커맨드 라인 인수들을 벡터로 모으고 출력하기
use std::env;

fn main() {
	let args: Vec<String> = env::args().collect();
	dbg!(args);
}
```

- 먼저 `use`를 사용하여 `std::env` 모듈을 스코프로 가져와서 `args` 함수를 사용할 수 있게 한다.
- 이렇게 하면 `std::env` 의 다른 함수들도 쉽게 사용할 수 있다.
- 또한 이렇게 하는 것이 `use std::env::args`를 추가하고 `args` 만으로 함수를 호출하는 것보다 덜 모호하다.
	- 이는 `args`가 현재의 모듈 내에 정의된 다른 함수로 쉽게 오해받을 수 있기 때문이다.

- 어떤 인수에라도 유효하지 않은 유니코드가 들어있다면  `std::env::args`가 `panic` 을 일으킨다.
	- 해결법: `std::env::args_os`를 대신 사용
	- 이 함수는 String 대신 OsString 값을 생성하는 반복자를 반환한다.

- main 함수의 첫째 줄에는 `env::args`를 호출한 즉시 `collect`를 사용하여 반복자에 의해 만들어지는 모든 값을 담고 있는 벡터로 바꾼다.