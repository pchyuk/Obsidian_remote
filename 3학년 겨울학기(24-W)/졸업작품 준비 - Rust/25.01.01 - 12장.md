### 커맨드 라인 인수 받기
- 언제나처럼 `cargo new` 를 사용해서 새 프로젝트를 만든다.
- 새 프로젝트의 이름은 `minigrep` 이다.

```shell
$ cargo new minigrep 
	Created binary (application) `minigrep` project 
$ cd minigrep
```

- minigrep 프로젝트: 2개의 커맨드라인 인수를 받는다.
	- 검색할 파일 경로, 문자열
	- cargo run 대신 프로그램 사용을 위한 인수가 나올 것임을 알려주는 두 개의 하이픈(--), 검색을 위한 문자열, 그리고 검색을 원하는 파일 이름

``` shell
$ cargo run -- searchstring example-filename.txt
```

- 현재 `cargo new` 로 생성한 기본 프로그램은 입력한 인수를 처리할 수 없다.
- crates.io에 있는 라이브러리를 사용하면 인수를 받는 프로그램 작성에 도움이 되겠지만, 지금은 배우는 단계이므로 직접 기능을 구현해 보자.

### 인수 값 읽기
- `minigrep` 프로젝트가 위의 커맨드 라인 인수로 전달된 값을 읽을 수 있도록 하기 위해서는 러스트의 표준 라이브러리가 제공하는 `std::env::args` 함수를 사용해야 한다.
	- 이 함수는 프로젝트로 넘겨진 커맨드 라인 인수의 반복자(iterator)를 반환한다.
	- 반복자에 대한 자세한 설명은 13장에서 공부한다.
	- 지금 반복자에 대해 알아야 할 2가지 세부사항
	- 1. 반복자는 일련의 값을 생성한다.
	- 2. 반복자의 `collect` 메서드를 호출하여 반복자가 생성하는 모든 요소를 담고 있는 벡터 같은 컬렉션으로 바꿀 수 있다.

```rust
// 예제 12-1: 커맨드 라인 인수들을 벡터로 모으고 출력하기
use std::env;

fn main() {
	let args: Vec<String> = env::args().collect();
	dbg!(args);
}
```

- 먼저 `use`를 사용하여 `std::env` 모듈을 스코프로 가져와서 `args` 함수를 사용할 수 있게 한다.
- 이렇게 하면 `std::env` 의 다른 함수들도 쉽게 사용할 수 있다.
- 또한 이렇게 하는 것이 `use std::env::args`를 추가하고 `args` 만으로 함수를 호출하는 것보다 덜 모호하다.
	- 이는 `args`가 현재의 모듈 내에 정의된 다른 함수로 쉽게 오해받을 수 있기 때문이다.

- 어떤 인수에라도 유효하지 않은 유니코드가 들어있다면  `std::env::args`가 `panic` 을 일으킨다.
	- 해결법: `std::env::args_os`를 대신 사용
	- 이 함수는 String 대신 OsString 값을 생성하는 반복자를 반환한다.

- main 함수의 첫째 줄에는 `env::args`를 호출한 즉시 `collect`를 사용하여 반복자에 의해 만들어지는 모든 값을 담고 있는 벡터로 바꾼다.
- 러스트에서는 타입을 명시할 필요가 거의 없지만, 러스트가 우리가 원하는 종류의 컬렉션을 추론할 수는 없으므로 `collect`는 타입 표기가 자주 필요한 함수 중 하나이다.

- 디버그 매크로를 사용해서 벡터를 출력해 보자.
- 먼저 인수 없이 코드를 실행해 보고
- 그 다음 인수 2개를 넣어 실행한다.

```shell
$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.61s
     Running `target/debug/minigrep`
[src/main.rs:5] args = [
    "target/debug/minigrep",
]

$ cargo run -- needle haystack
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 1.57s
     Running `target/debug/minigrep needle haystack`
[src/main.rs:5] args = [
    "target/debug/minigrep",
    "needle",
    "haystack",
]
```

- 벡터의 첫 번째 값은 "target/debug/minigrep", 즉 바이너리 파일의 이름이다.
	- C언어에서 main함수의 agrc, argv 입력과 동일하다.
		- argv[0]

### 인수 값들을 변수에 저장하기
```rust
// 예제 12-2: 질의(query) 인수와 파일 경로 인수를 담은 변수 생성하기
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    let query = &args[1];
    let file_path = &args[2];

    println!("Searching for {}", query);
    println!("In file {}", file_path);
}
```

- 프로그램의 이름이 벡터의 첫 번째 값 args[0]을 사용하므로
- 인덱스 1에 있는 인수부터 시작한다.
- 우리가 첫 번째 인수를 검색하고 싶은 문자열로 정했으므로,
- 첫 번째 인수의 참조자를 `query` 변수에 집어넣고,
- 두 번째 인수는 파일 경로이므로
- 두 번째 인수의 참조자를 `file_path` 에 집어넣는다.

```shell
user@pchyuk MINGW64 ~/Desktop/Rust_study/book/12/minigrep (main)
$ cargo run -- test sample.txt
   Compiling minigrep v0.1.0 (C:\Users\user\Desktop\Rust_study\book\12\minigrep)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.78s
     Running `target\debug\minigrep.exe test sample.txt`
Searching for test
In file sample.txt
```

- 잘 나온다